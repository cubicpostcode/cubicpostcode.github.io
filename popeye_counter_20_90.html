
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Water Bottle Counter</title>
<style>
  :root {
    --rainbow-bg: linear-gradient(90deg,
      #FF0018 0%, #FF0018 11.11%,
      #FFA52C 11.11%, #FFA52C 22.22%,
      #FFFF41 22.22%, #FFFF41 33.33%,
      #008018 33.33%, #008018 44.44%,
      #0000F9 44.44%, #0000F9 55.55%,
      #86007D 55.55%, #86007D 66.66%,
      #FFFFFF 66.66%, #FFFFFF 77.77%,
      #000000 77.77%, #000000 88.88%,
      #784F17 88.88%, #784F17 100%);
    --display-bg: rgba(0, 0, 0, 0.85);
    --bottle-area-bg: linear-gradient(to top, 
      rgba(15, 15, 15, 0.95) 0%,
      rgba(35, 35, 35, 0.85) 60%,
      rgba(0, 0, 0, 0.5) 100%);
    --active-color: #FFD700;
    --bottle-filled: linear-gradient(180deg,
      #E8F6FF 0%, #B8E0FF 25%, #80CCFF 50%, #4ABBFF 75%, #0099E6 100%);
    --bottle-active: linear-gradient(180deg,
      #FFE8F6 0%, #FFB8E0 25%, #FF80CC 50%, #FF4ABB 75%, #E60099 100%);
    --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    --shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
  }
  
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  body {
    background: var(--rainbow-bg);
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    position: relative;
    font-family: system-ui, -apple-system, sans-serif;
    user-select: none;
  }
  
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
  
  .loading {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 24px;
    font-weight: 600;
    z-index: 1000;
    opacity: 0;
    animation: fadeIn 0.5s ease forwards;
  }
  
  @keyframes fadeIn {
    to { opacity: 1; }
  }
  
  .main-display {
    display: flex;
    gap: clamp(15px, 3vw, 30px);
    background: var(--display-bg);
    backdrop-filter: blur(10px);
    padding: clamp(20px, 5vw, 50px);
    border-radius: 20px;
    margin-bottom: clamp(60px, 15vh, 120px);
    box-shadow: var(--shadow);
    z-index: 10;
    transition: var(--transition);
    position: absolute;
    top: clamp(40px, 8vh, 80px);
    left: 50%;
    transform: translateX(-50%);
  }
  
  .digit {
    width: clamp(80px, 15vw, 140px);
    height: clamp(100px, 20vw, 180px);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: clamp(60px, 12vw, 130px);
    font-weight: 700;
    border-radius: 15px;
    color: white;
    text-shadow: 0 4px 8px rgba(0, 0, 0, 0.6);
    transition: var(--transition);
  }
  
  .bottle-area {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    height: clamp(200px, 35vh, 400px);
    background: var(--bottle-area-bg);
    backdrop-filter: blur(5px);
    border-top: 3px solid rgba(255, 255, 255, 0.2);
    padding: 15px;
    z-index: 5;
    display: flex;
    flex-direction: column;
    justify-content: center;
  }
  
  .grid-container {
    display: grid;
    grid-template-rows: 1fr 1fr;
    grid-template-columns: repeat(8, 1fr);
    gap: clamp(5px, 1vw, 15px);
    width: 100%;
    height: 100%;
    max-width: 1400px;
    margin: 0 auto;
  }
  
  .bottle-box {
    display: grid;
    grid-template-columns: repeat(10, 1fr);
    grid-template-rows: repeat(10, 1fr);
    gap: 1px;
    background: rgba(30, 60, 90, 0.8);
    border: 2px solid rgba(100, 150, 200, 0.7);
    border-radius: 8px;
    padding: 4px;
    position: relative;
    transition: var(--transition);
    min-height: 60px;
    overflow: hidden;
    opacity: 0;
    transform: scale(0.8);
  }
  
  .bottle-box.visible {
    opacity: 1;
    transform: scale(1);
  }
  
  .bottle-box.active {
    transform: scale(1.1);
    border: 3px solid var(--active-color);
    background: rgba(255, 215, 0, 0.25);
    box-shadow: 0 0 25px rgba(255, 215, 0, 0.8);
    z-index: 15;
    animation: activeGlow 2s ease-in-out infinite;
  }
  
  @keyframes activeGlow {
    0%, 100% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); }
    50% { box-shadow: 0 0 35px rgba(255, 215, 0, 1); }
  }
  
  .bottle {
    width: 100%;
    height: 100%;
    border-radius: 2px;
    transition: var(--transition);
  }
  
  .bottle.filled {
    background: var(--bottle-filled);
    border: 0.5px solid rgba(0, 120, 220, 0.8);
    box-shadow: inset 0 1px 2px rgba(255, 255, 255, 0.4);
  }
  
  .bottle.empty {
    background: rgba(140, 140, 140, 0.15);
    border: 0.5px dashed rgba(120, 120, 120, 0.4);
  }
  
  .bottle-box.active .bottle.filled {
    background: var(--bottle-active);
    border: 0.5px solid rgba(220, 0, 120, 0.8);
    animation: bottlePulse 1.5s ease-in-out infinite;
  }
  
  .bottle-box.active .bottle.empty {
    background: rgba(255, 140, 140, 0.25);
    border: 0.5px dashed rgba(255, 120, 120, 0.6);
    animation: emptyPulse 1.5s ease-in-out infinite;
  }
  
  @keyframes bottlePulse {
    0%, 100% { opacity: 0.9; transform: scale(1); }
    50% { opacity: 1; transform: scale(1.02); }
  }
  
  @keyframes emptyPulse {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 0.5; }
  }
  
  .progress-bar {
    position: fixed;
    bottom: 0;
    left: 0;
    height: 4px;
    background: var(--active-color);
    transition: width 0.5s ease;
    z-index: 100;
    box-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
    width: 0%;
  }
  
  @media (max-width: 768px) {
    .bottle-area { height: 40vh; }
    .grid-container { gap: 5px; }
  }
  
  @media (max-width: 480px) {
    .main-display { gap: 10px; padding: 20px; }
    .bottle-area { height: 45vh; }
  }
  
  @media (prefers-reduced-motion: reduce) {
    *, *::before, *::after {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }
  }
</style>
</head>

<body>
  <div class="loading" id="loading">Initializing...</div>
  <div class="sr-only" role="region" aria-live="polite" id="announcer"></div>
  <div class="progress-bar" id="progressBar"></div>
  
  <main class="main-display" id="mainDisplay" aria-live="polite">
    <div class="digit">0</div>
    <div class="digit">0</div>
  </main>
  
  <div class="bottle-area">
    <div class="grid-container" id="gridContainer" role="presentation"></div>
  </div>

<script>
'use strict';

/**
 * Application Configuration
 */
const CONFIG = Object.freeze({
  SEQUENCE: [20, 21, 30, 31, 40, 41, 50, 51, 60, 61, 70, 71, 80, 81, 90, 91],
  SPEECH: {
    RATE: 0.7,
    PITCH: 1.0,
    VOLUME: 0.8,
    TIMEOUT: 8000,
    LANGUAGE: 'en-US'
  },
  TIMING: {
    STEP_DELAY: 2500,
    RESTART_DELAY: 3000,
    TRANSITION_DELAY: 100
  },
  GRID: {
    ROWS: 2,
    COLUMNS: 8,
    BOTTLES_PER_CONTAINER: 100,
    BOTTLES_PER_ROW: 10
  },
  DEBUG: false
});

/**
 * Number-to-word mapping for natural speech
 */
const NUMBER_WORDS = Object.freeze({
  20: "twenty", 21: "twenty one", 30: "thirty", 31: "thirty one",
  40: "forty", 41: "forty one", 50: "fifty", 51: "fifty one",
  60: "sixty", 61: "sixty one", 70: "seventy", 71: "seventy one",
  80: "eighty", 81: "eighty one", 90: "ninety", 91: "ninety one"
});

/**
 * Utility functions
 */
class Utils {
  static log(...args) {
    if (CONFIG.DEBUG) console.log('[BOTTLE-COUNTER]', ...args);
  }
  
  static createElement(tag, className = '', content = '') {
    const element = document.createElement(tag);
    if (className) element.className = className;
    if (content) element.textContent = content;
    return element;
  }
  
  static debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
  
  static delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  static formatNumber(number) {
    const tens = Math.floor(number / 10);
    const ones = number % 10;
    return { tens, ones };
  }
}

/**
 * DOM Manager - handles all DOM operations
 */
class DOMManager {
  constructor() {
    this.elements = this.getElements();
  }
  
  getElements() {
    return {
      loading: document.getElementById('loading'),
      mainDisplay: document.getElementById('mainDisplay'),
      gridContainer: document.getElementById('gridContainer'),
      progressBar: document.getElementById('progressBar'),
      announcer: document.getElementById('announcer')
    };
  }
  
  hideLoading() {
    this.elements.loading.style.display = 'none';
  }
  
  updateDisplay(number) {
    const { tens, ones } = Utils.formatNumber(number);
    this.elements.mainDisplay.innerHTML = `
      <div class="digit">${tens}</div>
      <div class="digit">${ones}</div>
    `;
  }
  
  updateProgress(current, total) {
    const percentage = ((current + 1) / total) * 100;
    this.elements.progressBar.style.width = `${percentage}%`;
  }
  
  announce(text) {
    this.elements.announcer.textContent = text;
  }
  
  clearGrid() {
    this.elements.gridContainer.innerHTML = '';
  }
}

/**
 * Speech Synthesis Manager
 */
class SpeechManager {
  constructor() {
    this.synth = window.speechSynthesis;
    this.isMuted = false;
    this.currentUtterance = null;
    this.isReady = false;
    this.preferredVoice = null;
    this.initializeVoices();
  }
  
  async initializeVoices() {
    const getVoices = () => {
      const voices = this.synth.getVoices();
      this.preferredVoice = this.selectBestVoice(voices);
      this.isReady = true;
      Utils.log('Speech ready with voice:', this.preferredVoice?.name || 'default');
    };
    
    if (this.synth.getVoices().length > 0) {
      getVoices();
    } else {
      this.synth.addEventListener('voiceschanged', getVoices, { once: true });
    }
  }
  
  selectBestVoice(voices) {
    // Priority: Google > Microsoft > default English > any English > first available
    const priorities = [
      voice => voice.lang.startsWith('en') && voice.name.includes('Google'),
      voice => voice.lang.startsWith('en') && voice.name.includes('Microsoft'),
      voice => voice.lang.startsWith('en') && voice.default,
      voice => voice.lang.startsWith('en'),
      () => true
    ];
    
    for (const priority of priorities) {
      const voice = voices.find(priority);
      if (voice) return voice;
    }
    
    return voices[0];
  }
  
  async speak(number) {
    if (!this.synth || this.isMuted || !this.isReady) {
      await Utils.delay(CONFIG.TIMING.STEP_DELAY);
      return;
    }
    
    await this.cancel();
    await Utils.delay(CONFIG.TIMING.TRANSITION_DELAY);
    
    return new Promise((resolve) => {
      const text = NUMBER_WORDS[number] || number.toString();
      const utterance = new SpeechSynthesisUtterance(text);
      
      this.configureUtterance(utterance);
      this.currentUtterance = utterance;
      
      let completed = false;
      const complete = () => {
        if (!completed) {
          completed = true;
          this.currentUtterance = null;
          Utils.log(`Speech completed: ${text}`);
          setTimeout(resolve, CONFIG.TIMING.STEP_DELAY);
        }
      };
      
      utterance.onend = complete;
      utterance.onerror = (e) => {
        Utils.log('Speech error:', e.error);
        complete();
      };
      
      setTimeout(complete, CONFIG.SPEECH.TIMEOUT);
      
      Utils.log(`Speaking: ${text}`);
      this.synth.speak(utterance);
    });
  }
  
  configureUtterance(utterance) {
    utterance.lang = CONFIG.SPEECH.LANGUAGE;
    utterance.rate = CONFIG.SPEECH.RATE;
    utterance.pitch = CONFIG.SPEECH.PITCH;
    utterance.volume = CONFIG.SPEECH.VOLUME;
    
    if (this.preferredVoice) {
      utterance.voice = this.preferredVoice;
    }
  }
  
  async cancel() {
    if (this.synth) {
      this.synth.cancel();
    }
    this.currentUtterance = null;
  }
  
  toggleMute() {
    this.isMuted = !this.isMuted;
    if (this.isMuted) {
      this.cancel();
    }
    return this.isMuted;
  }
}

/**
 * Bottle Container Factory
 */
class BottleContainerFactory {
  static create(number) {
    const container = Utils.createElement('div', 'bottle-box');
    container.setAttribute('data-number', number);
    container.setAttribute('role', 'img');
    container.setAttribute('aria-label', `${number} percent filled`);
    
    const fragment = document.createDocumentFragment();
    
    for (let i = 0; i < CONFIG.GRID.BOTTLES_PER_CONTAINER; i++) {
      const bottle = Utils.createElement('div', 'bottle');
      const shouldFill = this.shouldBottleBeFilled(number, i);
      bottle.classList.add(shouldFill ? 'filled' : 'empty');
      fragment.appendChild(bottle);
    }
    
    container.appendChild(fragment);
    this.positionContainer(container, number);
    
    return container;
  }
  
  static shouldBottleBeFilled(number, index) {
    if (number % 10 === 0) {
      return index < number;
    }
    
    const completeRows = Math.floor(number / 10);
    const extraBottles = number % 10;
    const row = Math.floor(index / CONFIG.GRID.BOTTLES_PER_ROW);
    const col = index % CONFIG.GRID.BOTTLES_PER_ROW;
    
    return row < completeRows || (row === completeRows && col < extraBottles);
  }
  
  static positionContainer(container, value) {
    // Map values to specific grid positions in 2×8 layout
    const positions = {
      20: { row: 1, col: 1 }, 21: { row: 2, col: 1 },
      30: { row: 1, col: 2 }, 31: { row: 2, col: 2 },
      40: { row: 1, col: 3 }, 41: { row: 2, col: 3 },
      50: { row: 1, col: 4 }, 51: { row: 2, col: 4 },
      60: { row: 1, col: 5 }, 61: { row: 2, col: 5 },
      70: { row: 1, col: 6 }, 71: { row: 2, col: 6 },
      80: { row: 1, col: 7 }, 81: { row: 2, col: 7 },
      90: { row: 1, col: 8 }, 91: { row: 2, col: 8 }
    };
    
    const position = positions[value];
    if (position) {
      container.style.gridRow = String(position.row);
      container.style.gridColumn = String(position.col);
    }
  }
}

/**
 * Animation Controller
 */
class AnimationController {
  static fadeInContainer(container) {
    requestAnimationFrame(() => {
      container.classList.add('visible');
      container.setAttribute('aria-hidden', 'false');
    });
  }
  
  static fadeOutContainer(container) {
    container.classList.remove('visible', 'active');
    container.setAttribute('aria-hidden', 'true');
  }
  
  static activateContainer(container) {
    container.classList.add('active');
  }
  
  static deactivateContainer(container) {
    container.classList.remove('active');
  }
}

/**
 * Main Application Controller
 */
class WaterBottleCounter {
  constructor() {
    this.currentIndex = 0;
    this.isRunning = false;
    this.containers = new Map();
    
    this.dom = new DOMManager();
    this.speech = new SpeechManager();
    
    this.init();
  }
  
  async init() {
    Utils.log('Initializing application...');
    
    try {
      await this.setupContainers();
      this.setupEventListeners();
      this.updateProgress();
      this.dom.hideLoading();
      
      Utils.log('Application initialized successfully');
      
      // Auto-start after initialization
      setTimeout(() => this.start(), 1000);
      
    } catch (error) {
      console.error('Initialization failed:', error);
      this.dom.elements.loading.textContent = 'Initialization failed';
    }
  }
  
  async setupContainers() {
    this.dom.clearGrid();
    
    return new Promise((resolve) => {
      requestAnimationFrame(() => {
        CONFIG.SEQUENCE.forEach((number) => {
          const container = BottleContainerFactory.create(number);
          this.containers.set(number, container);
          this.dom.elements.gridContainer.appendChild(container);
        });
        resolve();
      });
    });
  }
  
  setupEventListeners() {
    const keyboardHandlers = {
      'Space': (e) => {
        e.preventDefault();
        this.togglePlayPause();
      },
      'KeyR': () => this.reset(),
      'KeyM': () => this.toggleMute(),
      'KeyF': () => this.toggleFullscreen()
    };
    
    document.addEventListener('keydown', (e) => {
      const handler = keyboardHandlers[e.code];
      if (handler) handler(e);
    });
    
    document.addEventListener('click', Utils.debounce(() => {
      if (!document.fullscreenElement) {
        this.toggleFullscreen();
      }
    }, 1000));
  }
  
  updateDisplay(number) {
    this.dom.updateDisplay(number);
    this.dom.announce(`${number} percent`);
  }
  
  updateBottleGrid() {
    // Deactivate all containers
    this.containers.forEach(container => {
      AnimationController.deactivateContainer(container);
    });
    
    // Show containers up to current index
    for (let i = 0; i <= this.currentIndex && i < CONFIG.SEQUENCE.length; i++) {
      const number = CONFIG.SEQUENCE[i];
      const container = this.containers.get(number);
      
      if (container) {
        AnimationController.fadeInContainer(container);
        
        if (i === this.currentIndex) {
          AnimationController.activateContainer(container);
        }
      }
    }
  }
  
  updateProgress() {
    this.dom.updateProgress(this.currentIndex, CONFIG.SEQUENCE.length);
  }
  
  async step() {
    if (!this.isRunning) return;
    
    const currentNumber = CONFIG.SEQUENCE[this.currentIndex];
    
    this.updateDisplay(currentNumber);
    this.updateBottleGrid();
    this.updateProgress();
    
    Utils.log(`Step ${this.currentIndex + 1}/${CONFIG.SEQUENCE.length}: ${currentNumber}`);
    
    await this.speech.speak(currentNumber);
    
    this.currentIndex++;
    
    if (this.currentIndex >= CONFIG.SEQUENCE.length) {
      await this.restart();
    } else if (this.isRunning) {
      requestAnimationFrame(() => this.step());
    }
  }
  
  async restart() {
    Utils.log('Restarting sequence...');
    
    this.currentIndex = 0;
    this.updateProgress();
    
    // Hide all containers
    this.containers.forEach(container => {
      AnimationController.fadeOutContainer(container);
    });
    
    await Utils.delay(CONFIG.TIMING.RESTART_DELAY);
    
    if (this.isRunning) {
      this.step();
    }
  }
  
  start() {
    if (this.isRunning) return;
    
    this.isRunning = true;
    this.step();
    Utils.log('Counter started');
  }
  
  stop() {
    this.isRunning = false;
    this.speech.cancel();
    Utils.log('Counter stopped');
  }
  
  reset() {
    this.stop();
    this.currentIndex = 0;
    this.updateProgress();
    this.updateDisplay(0);
    
    this.containers.forEach(container => {
      AnimationController.fadeOutContainer(container);
    });
    
    this.dom.announce('Counter reset');
    Utils.log('Counter reset');
  }
  
  togglePlayPause() {
    if (this.isRunning) {
      this.stop();
    } else {
      this.start();
    }
  }
  
  toggleMute() {
    const isMuted = this.speech.toggleMute();
    this.dom.announce(isMuted ? 'Sound muted' : 'Sound enabled');
  }
  
  toggleFullscreen() {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().catch(() => {
        Utils.log('Fullscreen not supported');
      });
    } else {
      document.exitFullscreen().catch(() => {
        Utils.log('Exit fullscreen failed');
      });
    }
  }
}

/**
 * Application Entry Point
 */
document.addEventListener('DOMContentLoaded', () => {
  const app = new WaterBottleCounter();
  
  // Global error handling
  window.addEventListener('error', (e) => {
    console.error('Application error:', e.error);
  });
  
  window.addEventListener('unhandledrejection', (e) => {
    console.error('Unhandled promise rejection:', e.reason);
  });
});
</script>
</body>
</html>
