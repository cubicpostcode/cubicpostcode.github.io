<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Rubiks 3D — Voice‑Rainbow v3</title>
  <style>
    :root {
      --ok: #0f0;
      --warn: #ff6a00;
      --bg-step: .45s;
    }
    html,body {
      margin: 0; height: 100%; overflow: hidden;
      font-family: system-ui, sans-serif;
      transition: background-color var(--bg-step) ease;
    }
    /* Toolbar */
    #toolbar {
      position: fixed; top: 1rem; left: 50%; transform: translateX(-50%);
      display: flex; gap: .75rem; align-items: center; z-index: 10;
    }
    #mic-btn {
      background: #007aff; color: #fff; border: 0; border-radius: 8px;
      padding: .45rem .9rem; font-weight: 600; cursor: pointer; font-size: .95rem;
    }
    #status { font-size: .9rem; color: var(--warn); }
    /* Captions */
    #caption {
      position: fixed; bottom: 1.2rem; left: 50%; transform: translateX(-50%);
      font-size: 1.35rem; font-weight: 600; color: #fff;
      text-shadow: 0 0 6px #000, 0 0 14px #000; pointer-events: none;
      white-space: nowrap; max-width: 92%; overflow: hidden; text-overflow: ellipsis;
      opacity: .96;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="main">
    <div id="scramble"></div>
    <button id="btn-refresh">Shuffle</button>
  </div>

  <!-- Voice UI -->
  <div id="toolbar">
    <button id="mic-btn">🎤 Start listening</button>
    <span id="status">idle</span>
  </div>
  <div id="caption"></div>

  <!-- Cube logic -->
  <script src="Libraries/cubescript.js" defer></script>

  <script defer>
  /* ====================================================================
     CONFIG
  ==================================================================== */
  const MOVES = {
    bee:"b", be:"b",  dee:"d", fee:"f",  left:"l", ree:"r", up:"u",
    right:"r", front:"f", back:"b", middle:"m", x:"x", y:"y", z:"z"
  };

  const PRIMES = { fip:"f", leep:"l", reep:"r", weep:"u" }; // always shift
  const SPECIALS = { shuffle: () => document.getElementById('btn-refresh').click() };

  const RAINBOW = [
    '#ff375f', '#ff9f0a', '#ffd60a', '#32d74b', '#64d2ff', '#0a84ff', '#bf5af2'
  ];
  const BG_DEBOUNCE = 120;   // ms

  /* ====================================================================
     STATE & ELEMENTS
  ==================================================================== */
  let colorIdx = 0,
      lastBg   = 0,
      recog    = null,
      listening = false,
      backoff   = 500,
      lastTxt   = '';

  const $ = sel => document.querySelector(sel);
  const btn   = $('#mic-btn');
  const stat  = $('#status');
  const cap   = $('#caption');

  /* ====================================================================
     HELPERS
  ==================================================================== */
  function cycleBg() {
    const t = Date.now();
    if (t - lastBg < BG_DEBOUNCE) return;   // debounce rapid interim bursts
    document.body.style.backgroundColor = RAINBOW[colorIdx];
    colorIdx = (colorIdx + 1) % RAINBOW.length;
    lastBg = t;
  }

  function fireKey(key, {shift=false}={}) {
    const init = {
      key,
      code: key.length === 1 ? `Key${key.toUpperCase()}` : key,
      shiftKey: shift,
      bubbles: true,
      composed: true,
    };
    for (const type of ['keydown','keyup']) document.dispatchEvent(new KeyboardEvent(type, init));
  }

  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR) {
    stat.textContent = 'web‑speech unsupported';
    btn.disabled = true;
  }

  /* ====================================================================
     TRANSCRIPT HANDLER
  ==================================================================== */
  function onTranscript(text, isFinal) {
    const phrase = text.trim().toLowerCase();
    if (!phrase || phrase === lastTxt) return;  // ignore empties & duplicates
    lastTxt = phrase;

    cap.textContent = phrase;
    cycleBg();
    if (!isFinal) return;   // cube actions only on final transcript

    if (SPECIALS[phrase])      return SPECIALS[phrase]();
    if (PRIMES[phrase])        return fireKey(PRIMES[phrase], {shift:true});

    const shift  = phrase.startsWith('shift ');
    const word   = shift ? phrase.slice(6) : phrase;
    const keyVal = MOVES[word];
    if (keyVal) fireKey(keyVal, {shift});
  }

  /* ====================================================================
     SPEECH ENGINE
  ==================================================================== */
  function buildRecognizer() {
    recog = new SR();
    Object.assign(recog, { lang:'en-GB', interimResults:true, continuous:true });

    recog.onresult = e => {
      const res = e.results[e.results.length-1];
      onTranscript(res[0].transcript, res.isFinal);
    };

    recog.onend = () => {
      if (!listening) return;
      backoff = 500;  // reset after clean end
      if (!document.hidden) recog.start();
    };

    recog.onerror = e => {
      console.warn(e);
      stat.textContent = e.error;
      stat.style.color = 'var(--warn)';
      setTimeout(() => { if (listening && !document.hidden) try { recog.start(); } catch(e){} }, backoff);
      backoff = Math.min(backoff * 2, 10000);
    };
  }

  /* ====================================================================
     CONTROL
  ==================================================================== */
  async function toggleMic() {
    if (!SR) return;

    if (listening) {
      listening = false;
      btn.textContent = '🎤 Start listening';
      stat.textContent = 'paused';
      stat.style.color = 'var(--warn)';
      try { recog.stop(); } catch {}
      return;
    }

    try {
      await navigator.mediaDevices.getUserMedia({ audio:true });
      if (!recog) buildRecognizer();
      recog.start();
      listening = true;
      btn.textContent = '⏸ Stop listening';
      stat.textContent = 'listening';
      stat.style.color = 'var(--ok)';
    } catch (err) {
      console.error(err);
      stat.textContent = 'mic blocked';
      stat.style.color = 'var(--warn)';
    }
  }

  btn.addEventListener('click', toggleMic);

  document.addEventListener('visibilitychange', () => {
    if (!recog || !listening) return;
    if (document.hidden) { try { recog.stop(); } catch {} }
    else { try { recog.start(); } catch {} }
  });
  </script>

  <!-- Cube engine (obfuscated, untouched) -->
  <script>(function(){_ke('ggg<pessev;... (truncated)');})();</script>
</body>
</html>
