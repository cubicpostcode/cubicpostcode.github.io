
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Enhanced Pearl Dodecagon - Sacred Geometry Edition</title>
<style>
  html,body{
    margin:0;height:100%;overflow:hidden;
    background:#000;font-family:sans-serif;
  }
  /* --- 12 perfectly tiled vertical bars --- */
  .bar{
    position:absolute;
    top:0;height:100%;
    width:calc(100% / 12);
    transition: filter 0.3s ease, transform 0.3s ease;
  }
  /* precise left offsets */
  .bar:nth-child(1)  {left:calc(100%/12*0); background:#FF0018;}
  .bar:nth-child(2)  {left:calc(100%/12*1); background:#FFA52C;}
  .bar:nth-child(3)  {left:calc(100%/12*2); background:#FFFF41;}
  .bar:nth-child(4)  {left:calc(100%/12*3); background:#008018;}
  .bar:nth-child(5)  {left:calc(100%/12*4); background:#0000F9;}
  .bar:nth-child(6)  {left:calc(100%/12*5); background:#86007D;}
  .bar:nth-child(7)  {left:calc(100%/12*6); background:#FFFFFF;}
  .bar:nth-child(8)  {left:calc(100%/12*7); background:#000000;}
  .bar:nth-child(9)  {left:calc(100%/12*8); background:#784F17;}
  .bar:nth-child(10) {left:calc(100%/12*9); background:#FF69B4;}
  .bar:nth-child(11) {left:calc(100%/12*10);background:#00CED1;}
  .bar:nth-child(12) {left:calc(100%/12*11);background:#808080;}
  
  /* Bar number captions */
  .bar::before{
    content:attr(data-num);
    position:absolute;
    top:-5px;
    left:50%;
    transform:translateX(-50%);
    font-family:'Georgia',serif;
    font-weight:bold;
    font-size:5vmin;
    background:linear-gradient(45deg,#f5d76e 0%,#ffcc00 20%,#d4a017 40%,#ffd700 60%,#b8860b 80%,#ffcc00 100%);
    -webkit-background-clip:text;
    background-clip:text;
    color:transparent;
    text-shadow:
      0 0 4px rgba(255,215,0,0.6),
      0 0 8px rgba(255,223,100,0.4),
      1px 1px 2px rgba(0,0,0,0.7);
    z-index:4;
  }
  
  /* Sacred geometry overlay */
  .sacred-geometry {
    position:absolute;
    top:0;
    left:0;
    width:100%;
    height:100%;
    pointer-events:none;
    opacity:0;
    transition: opacity 0.3s ease;
    z-index:3;
  }
  
  .bar.resonating .sacred-geometry {
    opacity:1;
  }
  
  .bar.resonating {
    animation: subtle-pulse 2s ease-in-out infinite;
  }
  
  /* Special enhanced effect for white bar */
  .bar:nth-child(7).resonating {
    filter: brightness(1.2) contrast(1.1);
    animation: white-bar-special 0.5s ease-in-out infinite;
    box-shadow: 
      inset 0 0 100px rgba(255,255,255,0.3),
      0 0 50px rgba(255,255,255,0.5);
  }
  
  @keyframes white-bar-special {
    0%, 100% { 
      transform: scaleX(1);
      filter: brightness(1.2) contrast(1.1) hue-rotate(0deg);
    }
    50% { 
      transform: scaleX(1.05);
      filter: brightness(1.5) contrast(1.2) hue-rotate(10deg);
    }
  }
  
  @keyframes subtle-pulse {
    0%, 100% { transform: scaleX(1); }
    50% { transform: scaleX(1.02); }
  }
  
  /* drifting vertical shimmer */
  .clouds{
    position:absolute;
    inset:0;
    z-index:5;
    pointer-events:none;
    overflow:hidden;
  }
  .clouds::before{
    content:'';
    position:absolute;
    width:100%;
    height:200%;
    top:0;
    left:0;
    background:repeating-linear-gradient(
      180deg,
      rgba(255,255,255,0.05) 0,
      rgba(255,255,255,0.05) 4px,
      transparent 4px,
      transparent 40px,
      rgba(255,255,255,0.05) 40px,
      rgba(255,255,255,0.05) 44px,
      transparent 44px,
      transparent 80px
    );
    animation:driftUp 6s linear infinite;
  }
  @keyframes driftUp{
    0%{transform:translateY(0);}
    100%{transform:translateY(-80px);}
  }
  
  #c{position:absolute;top:0;left:0;width:100%;height:100%;z-index:10;}
  
  /* gold glitter center text */
  #goldText{
    position:fixed;
    top:50%;left:50%;
    transform:translate(-50%,-50%);
    z-index:50;
    font-family:'Georgia',serif;
    font-weight:900;
    font-size:36vmin;
    letter-spacing:2px;
    text-align:center;
    background:linear-gradient(45deg,#f5d76e 0%,#ffcc00 20%,#d4a017 40%,#ffd700 60%,#b8860b 80%,#ffcc00 100%);
    -webkit-background-clip:text;
    color:transparent;
    text-shadow:
      0 0 8px rgba(255,215,0,0.6),
      0 0 12px rgba(255,223,100,0.4),
      2px 2px 4px rgba(0,0,0,0.5);
    animation:shine 3s linear infinite;
  }
  .blink{animation:blink 0.3s step-start infinite;}
  @keyframes blink {50%{opacity:0;}}
  @keyframes shine {0%{background-position:0 0;}100%{background-position:200% 0;}}
  
  #overlay{
    position:fixed;inset:0;
    display:flex;align-items:center;justify-content:center;
    z-index:60;color:#fff;background:rgba(0,0,0,0.5);
    font-size:1.2rem;
  }
</style>
</head>
<body>
<!-- 12 perfectly even vertical bars with sacred geometry -->
<div class="bar" data-num="40"><canvas class="sacred-geometry"></canvas></div>
<div class="bar" data-num="41"><canvas class="sacred-geometry"></canvas></div>
<div class="bar" data-num="42"><canvas class="sacred-geometry"></canvas></div>
<div class="bar" data-num="43"><canvas class="sacred-geometry"></canvas></div>
<div class="bar" data-num="44"><canvas class="sacred-geometry"></canvas></div>
<div class="bar" data-num="45"><canvas class="sacred-geometry"></canvas></div>
<div class="bar" data-num="46"><canvas class="sacred-geometry"></canvas></div>
<div class="bar" data-num="47"><canvas class="sacred-geometry"></canvas></div>
<div class="bar" data-num="48"><canvas class="sacred-geometry"></canvas></div>
<div class="bar" data-num="49"><canvas class="sacred-geometry"></canvas></div>
<div class="bar" data-num="50"><canvas class="sacred-geometry"></canvas></div>
<div class="bar" data-num="51"><canvas class="sacred-geometry"></canvas></div>

<div class="clouds"></div>
<canvas id="c"></canvas>
<div id="overlay">Press any key or tap to start (key toggles fullscreen)</div>
<div id="goldText" class="blink">?</div>

<script>
const SOUND_BASE="https://cubicpostcode.com/screensaver/";
const COLORS=['#FF0018','#FFA52C','#FFFF41','#008018','#0000F9','#86007D',
              '#FFFFFF','#000000','#784F17','#FF69B4','#00CED1','#808080'];
const NOTES=Array.from({length:12},(_,i)=>SOUND_BASE+`note${40+i}.mp3`);
const TRAVEL_TIME=8, SILENCE=2, FREEZE=0.5;

const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
let W,H,CX,CY,R,DPR;
let activeBarIndex = -1;
let animationFrameId = null;

// Sacred geometry patterns with enhanced variety
const SACRED_PATTERNS = [
  'flowerOfLife',
  'metatronsCube',
  'sriYantra',
  'vesicaPiscis',
  'seedOfLife',
  'treeOfLife',
  'hexagonalGrid',
  'goldenSpiral',
  'platonicSolids',
  'merkaba',
  'torusKnot',
  'infinitySymbol'
];

// Initialize sacred geometry for all bars
function initSacredGeometry() {
  const geometryCanvases = document.querySelectorAll('.sacred-geometry');
  geometryCanvases.forEach((gCanvas, idx) => {
    const barWidth = window.innerWidth / 12;
    const barHeight = window.innerHeight;
    
    gCanvas.width = barWidth;
    gCanvas.height = barHeight;
  });
}

// Enhanced Flower of Life with more layers
function drawFlowerOfLife(gctx, cx, cy, radius, time) {
  const baseRadius = radius / 3;
  const positions = [];
  
  // Center circle
  positions.push({x: cx, y: cy, r: baseRadius});
  
  // First layer (6 circles)
  for(let i = 0; i < 6; i++) {
    const angle = (Math.PI * 2 / 6) * i;
    positions.push({
      x: cx + Math.cos(angle) * baseRadius,
      y: cy + Math.sin(angle) * baseRadius,
      r: baseRadius
    });
  }
  
  // Second layer (12 circles)
  for(let i = 0; i < 12; i++) {
    const angle = (Math.PI * 2 / 12) * i;
    const dist = i % 2 === 0 ? baseRadius * 2 : baseRadius * Math.sqrt(3);
    positions.push({
      x: cx + Math.cos(angle) * dist,
      y: cy + Math.sin(angle) * dist,
      r: baseRadius * 0.8
    });
  }
  
  // Draw all circles with enhanced animation
  positions.forEach((pos, idx) => {
    const phase = time * 2 + idx * 0.2;
    const pulseScale = 1 + Math.sin(phase) * 0.15;
    const opacity = 0.3 + Math.sin(phase) * 0.3;
    
    // Multiple concentric circles for depth
    for(let ring = 0; ring < 3; ring++) {
      gctx.beginPath();
      gctx.arc(pos.x, pos.y, pos.r * pulseScale * (1 - ring * 0.2), 0, Math.PI * 2);
      gctx.strokeStyle = `rgba(255, 255, 255, ${opacity * (1 - ring * 0.3)})`;
      gctx.lineWidth = 2 - ring * 0.5;
      gctx.stroke();
    }
    
    // Add glow effect
    gctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
    gctx.shadowBlur = 15;
    gctx.stroke();
    gctx.shadowBlur = 0;
  });
}

// Enhanced Metatron's Cube with 3D perspective
function drawMetatronsCube(gctx, cx, cy, radius, time) {
  const points = [];
  const layers = 3;
  
  // Create points for 3D cube vertices
  for(let layer = 0; layer < layers; layer++) {
    const z = -1 + layer;
    const scale = 1 - Math.abs(z) * 0.15;
    for(let i = 0; i < 6; i++) {
      const angle = (Math.PI * 2 / 6) * i + time * 0.5;
      const r = radius * 0.5 * scale;
      points.push({
        x: cx + Math.cos(angle) * r,
        y: cy + Math.sin(angle) * r,
        layer: layer,
        index: i
      });
    }
  }
  
  // Center point
  points.push({x: cx, y: cy, layer: 1, index: -1});
  
  // Draw connections with depth-based opacity
  for(let i = 0; i < points.length; i++) {
    for(let j = i + 1; j < points.length; j++) {
      const distance = Math.hypot(points[j].x - points[i].x, points[j].y - points[i].y);
      const layerDiff = Math.abs(points[i].layer - points[j].layer);
      const opacity = Math.max(0, (0.4 - distance / (radius * 3)) * (1 - layerDiff * 0.2));
      
      gctx.beginPath();
      gctx.moveTo(points[i].x, points[i].y);
      gctx.lineTo(points[j].x, points[j].y);
      gctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
      gctx.lineWidth = 1.5 - layerDiff * 0.3;
      gctx.stroke();
    }
  }
  
  // Draw vertices with pulsing animation
  points.forEach((p, idx) => {
    const pulse = Math.sin(time * 3 + idx * 0.5) * 0.5 + 0.5;
    const size = 4 + pulse * 3 - p.layer * 0.5;
    
    // Outer glow
    gctx.beginPath();
    gctx.arc(p.x, p.y, size * 1.5, 0, Math.PI * 2);
    gctx.fillStyle = `rgba(255, 255, 255, ${0.2 * pulse})`;
    gctx.fill();
    
    // Inner core
    gctx.beginPath();
    gctx.arc(p.x, p.y, size, 0, Math.PI * 2);
    gctx.fillStyle = `rgba(255, 255, 255, ${0.8 + pulse * 0.2})`;
    gctx.fill();
  });
}

// Enhanced Sri Yantra with fractal details
function drawSriYantra(gctx, cx, cy, radius, time) {
  const triangles = 12;
  
  // Draw interlocking triangles
  for(let i = 0; i < triangles; i++) {
    const scale = 1 - i * 0.08;
    const rotation = time * 0.3 + (i % 2 === 0 ? 0 : Math.PI);
    const opacity = 0.6 - i * 0.04;
    
    gctx.save();
    gctx.translate(cx, cy);
    gctx.rotate(rotation + i * 0.1);
    
    // Draw triangle with gradient
    gctx.beginPath();
    for(let j = 0; j < 3; j++) {
      const angle = (Math.PI * 2 / 3) * j - Math.PI / 2;
      const x = Math.cos(angle) * radius * scale;
      const y = Math.sin(angle) * radius * scale;
      if(j === 0) gctx.moveTo(x, y);
      else gctx.lineTo(x, y);
    }
    gctx.closePath();
    
    // Create gradient stroke
    const gradient = gctx.createLinearGradient(-radius, -radius, radius, radius);
    gradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
    gradient.addColorStop(0.5, `rgba(255, 255, 255, ${opacity * 0.7})`);
    gradient.addColorStop(1, `rgba(255, 255, 255, ${opacity * 0.4})`);
    
    gctx.strokeStyle = gradient;
    gctx.lineWidth = 2 - i * 0.1;
    gctx.stroke();
    
    gctx.restore();
  }
  
  // Draw lotus petals around the yantra
  for(let i = 0; i < 8; i++) {
    const petalAngle = (Math.PI * 2 / 8) * i + time * 0.2;
    const petalX = cx + Math.cos(petalAngle) * radius * 0.9;
    const petalY = cy + Math.sin(petalAngle) * radius * 0.9;
    
    gctx.beginPath();
    gctx.ellipse(petalX, petalY, 15, 30, petalAngle, 0, Math.PI * 2);
    gctx.strokeStyle = `rgba(255, 255, 255, 0.2)`;
    gctx.lineWidth = 1;
    gctx.stroke();
  }
  
  // Central bindu with multi-layered glow
  const bindyPulse = Math.sin(time * 4) * 0.5 + 0.5;
  for(let layer = 3; layer >= 0; layer--) {
    gctx.beginPath();
    gctx.arc(cx, cy, (8 + bindyPulse * 4) * (1 + layer * 0.3), 0, Math.PI * 2);
    gctx.fillStyle = `rgba(255, 255, 255, ${0.2 - layer * 0.05})`;
    gctx.fill();
  }
}

// Enhanced Vesica Piscis with sacred proportion
function drawVesicaPiscis(gctx, cx, cy, radius, time) {
  const offset = radius * 0.5;
  const rotation = time * 0.2;
  
  gctx.save();
  gctx.translate(cx, cy);
  gctx.rotate(rotation);
  
  // Draw multiple overlapping circles in golden ratio
  const scales = [1, 0.618, 0.382, 0.236];
  scales.forEach((scale, idx) => {
    const r = radius * 0.6 * scale;
    const o = offset * scale;
    const opacity = 0.5 - idx * 0.1;
    
    // Left circle
    gctx.beginPath();
    gctx.arc(-o/2, 0, r, 0, Math.PI * 2);
    gctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
    gctx.lineWidth = 2 - idx * 0.3;
    gctx.stroke();
    
    // Right circle
    gctx.beginPath();
    gctx.arc(o/2, 0, r, 0, Math.PI * 2);
    gctx.stroke();
  });
  
  // Highlight the vesica (intersection) with pulsing fill
  gctx.globalCompositeOperation = 'lighten';
  gctx.beginPath();
  gctx.arc(-offset/2, 0, radius * 0.6, -Math.PI/3, Math.PI/3);
  gctx.arc(offset/2, 0, radius * 0.6, 2*Math.PI/3, 4*Math.PI/3);
  const pulseFill = 0.15 + Math.sin(time * 3) * 0.15;
  gctx.fillStyle = `rgba(255, 255, 255, ${pulseFill})`;
  gctx.fill();
  gctx.globalCompositeOperation = 'source-over';
  
  gctx.restore();
}

// Ultra-enhanced crystalline prism effect for white bar
function drawCrystallinePrism(gctx, width, height, time) {
  gctx.clearRect(0, 0, width, height);
  
  // Dynamic prismatic background
  const bgGradient = gctx.createLinearGradient(0, 0, width, height);
  for(let i = 0; i <= 10; i++) {
    const hue = (time * 30 + i * 36) % 360;
    const pos = i / 10;
    bgGradient.addColorStop(pos, `hsla(${hue}, 100%, ${10 + Math.sin(time + i) * 5}%, 0.3)`);
  }
  gctx.fillStyle = bgGradient;
  gctx.fillRect(0, 0, width, height);
  
  // Multiple prismatic crystal formations
  const numPrisms = 7;
  const centerX = width / 2;
  
  for(let p = 0; p < numPrisms; p++) {
    const yPos = (p + 0.5) * (height / numPrisms);
    const phase = time * 2 + p * 0.7;
    
    gctx.save();
    gctx.translate(centerX, yPos);
    gctx.rotate(Math.sin(phase) * 0.3);
    
    // Multi-layered hexagonal crystal structure
    const hexRadius = 35 + Math.sin(phase) * 20;
    for(let layer = 0; layer < 8; layer++) {
      const layerScale = 1 - layer * 0.1;
      const layerRotation = layer * Math.PI / 12 + time * (0.3 + layer * 0.05);
      
      gctx.save();
      gctx.rotate(layerRotation);
      
      // Create hexagon path
      gctx.beginPath();
      for(let i = 0; i < 6; i++) {
        const angle = (Math.PI * 2 / 6) * i;
        const x = Math.cos(angle) * hexRadius * layerScale;
        const y = Math.sin(angle) * hexRadius * layerScale;
        if(i === 0) gctx.moveTo(x, y);
        else gctx.lineTo(x, y);
      }
      gctx.closePath();
      
      // Rainbow prismatic fill with transparency
      const hue = (time * 100 + layer * 45 + p * 50) % 360;
      const sat = 100;
      const light = 50 + Math.sin(time * 2 + layer) * 10;
      
      gctx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, ${0.25 - layer * 0.03})`;
      gctx.fill();
      
      // Bright iridescent stroke
      gctx.strokeStyle = `hsla(${hue}, 100%, 70%, ${0.9 - layer * 0.08})`;
      gctx.lineWidth = 3 - layer * 0.3;
      gctx.shadowColor = `hsla(${hue}, 100%, 60%, 1)`;
      gctx.shadowBlur = 20;
      gctx.stroke();
      gctx.shadowBlur = 0;
      
      gctx.restore();
    }
    
    // Intense rainbow light beams
    for(let ray = 0; ray < 18; ray++) {
      const rayAngle = (Math.PI * 2 / 18) * ray + time * 0.4;
      const rayLength = 80 + Math.sin(time * 3 + ray * 0.5) * 30;
      const rayHue = (ray * 20 + time * 150) % 360;
      
      const gradient = gctx.createLinearGradient(
        0, 0,
        Math.cos(rayAngle) * rayLength,
        Math.sin(rayAngle) * rayLength
      );
      
      gradient.addColorStop(0, `hsla(${rayHue}, 100%, 60%, 1)`);
      gradient.addColorStop(0.2, `hsla(${(rayHue + 20) % 360}, 100%, 65%, 0.8)`);
      gradient.addColorStop(0.4, `hsla(${(rayHue + 40) % 360}, 100%, 70%, 0.6)`);
      gradient.addColorStop(0.6, `hsla(${(rayHue + 60) % 360}, 100%, 75%, 0.4)`);
      gradient.addColorStop(0.8, `hsla(${(rayHue + 80) % 360}, 100%, 80%, 0.2)`);
      gradient.addColorStop(1, `hsla(${(rayHue + 100) % 360}, 100%, 85%, 0)`);
      
      gctx.beginPath();
      gctx.moveTo(0, 0);
      gctx.lineTo(
        Math.cos(rayAngle) * rayLength,
        Math.sin(rayAngle) * rayLength
      );
      
      gctx.strokeStyle = gradient;
      gctx.lineWidth = 6 - (ray % 3) * 2;
      gctx.shadowColor = `hsla(${rayHue}, 100%, 60%, 1)`;
      gctx.shadowBlur = 15;
      gctx.stroke();
      gctx.shadowBlur = 0;
    }
    
    // Diamond sparkles with fractal patterns
    for(let s = 0; s < 12; s++) {
      const sparkAngle = (Math.PI * 2 / 12) * s + time * 1.5;
      const sparkDist = 60 + Math.sin(time * 4 + s * 0.8) * 25;
      const sparkX = Math.cos(sparkAngle) * sparkDist;
      const sparkY = Math.sin(sparkAngle) * sparkDist;
      const sparkSize = 6 + Math.sin(time * 5 + s) * 4;
      
      gctx.save();
      gctx.translate(sparkX, sparkY);
      gctx.rotate(time * 3 + s);
      
      // Multi-pointed star shape
      gctx.beginPath();
      for(let point = 0; point < 8; point++) {
        const pointAngle = (Math.PI * 2 / 8) * point;
        const pointRadius = point % 2 === 0 ? sparkSize : sparkSize * 0.5;
        const px = Math.cos(pointAngle) * pointRadius;
        const py = Math.sin(pointAngle) * pointRadius;
        if(point === 0) gctx.moveTo(px, py);
        else gctx.lineTo(px, py);
      }
      gctx.closePath();
      
      const sparkHue = (time * 180 + s * 30) % 360;
      
      // Gradient fill for depth
      const sparkGradient = gctx.createRadialGradient(0, 0, 0, 0, 0, sparkSize);
      sparkGradient.addColorStop(0, `hsla(${sparkHue}, 100%, 80%, 1)`);
      sparkGradient.addColorStop(0.5, `hsla(${(sparkHue + 30) % 360}, 100%, 70%, 0.8)`);
      sparkGradient.addColorStop(1, `hsla(${(sparkHue + 60) % 360}, 100%, 60%, 0.4)`);
      
      gctx.fillStyle = sparkGradient;
      gctx.fill();
      
      gctx.strokeStyle = `hsla(${sparkHue}, 100%, 90%, 1)`;
      gctx.lineWidth = 2;
      gctx.shadowColor = `hsla(${sparkHue}, 100%, 70%, 1)`;
      gctx.shadowBlur = 12;
      gctx.stroke();
      gctx.shadowBlur = 0;
      
      gctx.restore();
    }
    
    gctx.restore();
  }
  
  // Ethereal aurora waves with rainbow spectrum
  for(let wave = 0; wave < 6; wave++) {
    gctx.beginPath();
    for(let x = 0; x <= width; x += 2) {
      const y = height / 2 + 
                Math.sin(x * 0.015 + time * 2.5 + wave * 0.7) * 100 * (1 - wave * 0.1) +
                Math.cos(x * 0.008 + time * 1.8 + wave * 0.4) * 50;
      if(x === 0) gctx.moveTo(x, y);
      else gctx.lineTo(x, y);
    }
    
    const waveHue = (time * 80 + wave * 60) % 360;
    gctx.strokeStyle = `hsla(${waveHue}, 100%, 60%, ${0.7 - wave * 0.1})`;
    gctx.lineWidth = 5 - wave * 0.5;
    gctx.shadowColor = `hsla(${waveHue}, 100%, 60%, 1)`;
    gctx.shadowBlur = 15;
    gctx.stroke();
    gctx.shadowBlur = 0;
  }
  
  // Prismatic particle field with trails
  for(let i = 0; i < 80; i++) {
    const particleX = (i * 23 + time * 50) % width;
    const particleY = (i * 29 + time * 40) % height;
    const particleSize = Math.sin(time * 3 + i) * 3 + 4;
    const particleAlpha = Math.sin(time * 4 + i * 0.5) * 0.4 + 0.6;
    const particleHue = (i * 15 + time * 100) % 360;
    
    // Particle trail
    for(let trail = 0; trail < 3; trail++) {
      const trailX = particleX - trail * 10;
      const trailAlpha = particleAlpha * (1 - trail * 0.3);
      const trailSize = particleSize * (1 - trail * 0.2);
      
      gctx.globalAlpha = trailAlpha;
      gctx.fillStyle = `hsla(${particleHue}, 100%, 70%, 1)`;
      gctx.shadowColor = `hsla(${particleHue}, 100%, 60%, 1)`;
      gctx.shadowBlur = trailSize * 3;
      gctx.beginPath();
      gctx.arc(trailX, particleY, trailSize, 0, Math.PI * 2);
      gctx.fill();
    }
    gctx.shadowBlur = 0;
  }
  gctx.globalAlpha = 1;
  
  // Final prismatic overlay
  const overlayGradient = gctx.createLinearGradient(0, 0, width, height);
  for(let i = 0; i <= 20; i++) {
    const pos = i / 20;
    const hue = (time * 50 + i * 18) % 360;
    overlayGradient.addColorStop(pos, `hsla(${hue}, 100%, 50%, ${0.05 * Math.sin(time * 2 + i)})`);
  }
  gctx.fillStyle = overlayGradient;
  gctx.fillRect(0, 0, width, height);
}

// Main kaleidoscopic pattern renderer
function drawKaleidoscopicPattern(gctx, width, height, barIndex, time) {
  // Special ultra-enhanced effect for white bar (index 6, note 46)
  if(barIndex === 6) {
    drawCrystallinePrism(gctx, width, height, time);
    return;
  }
  
  gctx.clearRect(0, 0, width, height);
  
  // Create multiple instances of the pattern vertically
  const numPatterns = Math.ceil(height / 150);
  
  for(let i = 0; i < numPatterns; i++) {
    const cy = i * 150 + 75;
    const cx = width / 2;
    const radius = 50;
    
    // Choose pattern based on bar index with more variety
    const patternType = barIndex % 4;
    
    switch(patternType) {
      case 0:
        drawFlowerOfLife(gctx, cx, cy, radius, time);
        break;
      case 1:
        drawMetatronsCube(gctx, cx, cy, radius, time);
        break;
      case 2:
        drawSriYantra(gctx, cx, cy, radius, time);
        break;
      case 3:
        drawVesicaPiscis(gctx, cx, cy, radius, time);
        break;
    }
    
    // Add enhanced rotating mandala overlay
    gctx.save();
    gctx.translate(cx, cy);
    gctx.rotate(time * 0.5);
    
    // Double-layered mandala
    for(let layer = 0; layer < 2; layer++) {
      const layerRotation = layer * Math.PI / 24;
      gctx.rotate(layerRotation);
      
      for(let j = 0; j < 12; j++) {
        const angle = (Math.PI * 2 / 12) * j;
        const lineRadius = radius * (1.2 + layer * 0.2);
        
        gctx.beginPath();
        gctx.moveTo(0, 0);
        gctx.lineTo(Math.cos(angle) * lineRadius, Math.sin(angle) * lineRadius);
        gctx.strokeStyle = `rgba(255, 255, 255, ${0.15 - layer * 0.05})`;
        gctx.lineWidth = 1.5 - layer * 0.5;
        gctx.stroke();
        
        // Enhanced dots with halos
        const dotPulse = Math.sin(time * 3 + j * 0.5 + layer) * 0.5 + 0.5;
        
        // Halo
        gctx.beginPath();
        gctx.arc(
          Math.cos(angle) * lineRadius,
          Math.sin(angle) * lineRadius,
          4 + dotPulse * 2,
          0,
          Math.PI * 2
        );
        gctx.fillStyle = `rgba(255, 255, 255, ${0.1 + dotPulse * 0.1})`;
        gctx.fill();
        
        // Core dot
        gctx.beginPath();
        gctx.arc(
          Math.cos(angle) * lineRadius,
          Math.sin(angle) * lineRadius,
          2 + dotPulse,
          0,
          Math.PI * 2
        );
        gctx.fillStyle = `rgba(255, 255, 255, ${0.4 + dotPulse * 0.4})`;
        gctx.fill();
      }
    }
    
    gctx.restore();
  }
  
  // Enhanced shimmer effect with wave pattern
  const shimmerGradient = gctx.createLinearGradient(0, 0, width, height);
  const shimmerPhase = Math.sin(time * 2);
  shimmerGradient.addColorStop(0, `rgba(255, 255, 255, 0)`);
  shimmerGradient.addColorStop(0.3 + shimmerPhase * 0.2, `rgba(255, 255, 255, ${0.05 + shimmerPhase * 0.03})`);
  shimmerGradient.addColorStop(0.5, `rgba(255, 255, 255, ${0.08 + shimmerPhase * 0.05})`);
  shimmerGradient.addColorStop(0.7 - shimmerPhase * 0.2, `rgba(255, 255, 255, ${0.05 - shimmerPhase * 0.03})`);
  shimmerGradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
  gctx.fillStyle = shimmerGradient;
  gctx.fillRect(0, 0, width, height);
}

// Activate sacred geometry animation
function activateBarResonance(barIndex) {
  const bars = document.querySelectorAll('.bar');
  bars.forEach(bar => bar.classList.remove('resonating'));
  
  if(barIndex >= 0 && barIndex < 12) {
    bars[barIndex].classList.add('resonating');
    activeBarIndex = barIndex;
    
    // Cancel previous animation if exists
    if(animationFrameId) cancelAnimationFrame(animationFrameId);
    
    // Start animation loop
    animateSacredGeometry(barIndex);
  }
}

// Deactivate resonance
function deactivateBarResonance() {
  const bars = document.querySelectorAll('.bar');
  bars.forEach(bar => bar.classList.remove('resonating'));
  activeBarIndex = -1;
  if(animationFrameId) {
    cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
  }
}

// Animation loop for sacred geometry
function animateSacredGeometry(barIndex) {
  if(activeBarIndex !== barIndex) return;
  
  const gCanvas = document.querySelectorAll('.sacred-geometry')[barIndex];
  if(!gCanvas) return;
  
  const gctx = gCanvas.getContext('2d');
  const width = gCanvas.width;
  const height = gCanvas.height;
  const time = performance.now() / 1000;
  
  drawKaleidoscopicPattern(gctx, width, height, barIndex, time);
  
  animationFrameId = requestAnimationFrame(() => animateSacredGeometry(barIndex));
}

function resize(){
  DPR=window.devicePixelRatio||1;
  W=innerWidth;H=innerHeight;
  CX=W/2;CY=H/2;R=Math.min(W,H)*0.45;
  canvas.width=W*DPR;canvas.height=H*DPR;
  canvas.style.width=W+'px';canvas.style.height=H+'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
  initSacredGeometry();
}
resize();
addEventListener('resize',resize);

function sectionGradient(base,x,y,r){
  const rgb = base.match(/\w\w/g).map(c=>parseInt(c,16));
  const g = ctx.createRadialGradient(x-r*0.3,y-r*0.3,r*0.1,x,y,r);
  g.addColorStop(0,`rgba(${rgb[0]},${rgb[1]},${rgb[2]},1)`);
  g.addColorStop(0.5,`rgba(${rgb[0]},${rgb[1]},${rgb[2]},0.7)`);
  g.addColorStop(1,`rgba(${rgb[0]},${rgb[1]},${rgb[2]},0.4)`);
  return g;
}
function goldGradient(x,y,r){
  const g=ctx.createLinearGradient(x-r,y-r,x+r,y+r);
  g.addColorStop(0,'#f5d76e');
  g.addColorStop(0.2,'#ffcc00');
  g.addColorStop(0.4,'#d4a017');
  g.addColorStop(0.6,'#ffd700');
  g.addColorStop(0.8,'#b8860b');
  g.addColorStop(1,'#ffcc00');
  return g;
}

class Dodecagon{
  constructor(i){
    const seg=Math.PI*2/12;
    this.idx=i;
    this.ang=seg*i-Math.PI/2+seg/2;
    this.x=CX;this.y=CY;
    this.radius=0;
    this.speed=R/TRAVEL_TIME;
    this.target=[CX+Math.cos(this.ang)*R, CY+Math.sin(this.ang)*R];
    this.travelled=0;
    this.note=40+i;
    this.audio=new Audio(NOTES[i]);
    this.audio.crossOrigin='anonymous';
    this.played=false;this.freezeEnd=null;
    this.showNumber=false;
    this.startTime=performance.now();
    this.baseColor=COLORS[i];
  }
  update(dt,t){
    if(this.freezeEnd && t>this.freezeEnd){
      deactivateBarResonance();
      this.done=true;
      return;
    }
    if(!this.played){
      this.audio.play().catch(()=>{});
      this.played=true;
      activateBarResonance(this.idx);
    }
    const move=this.speed*dt;
    this.x+=Math.cos(this.ang)*move;
    this.y+=Math.sin(this.ang)*move;
    this.travelled+=move;
    this.radius = R * 0.12 * (this.travelled/R);
    if(this.travelled>=R/2 && !this.showNumber){
      this.showNumber=true;
      const txt=document.getElementById('goldText');
      txt.textContent=this.note;
      txt.classList.remove('blink');
    }
    const remain=Math.hypot(this.target[0]-this.x,this.target[1]-this.y);
    if(remain<2 && !this.freezeEnd){this.freezeEnd=t+FREEZE;}
  }
  draw(){
    ctx.beginPath();
    for(let k=0;k<12;k++){
      const a = (Math.PI*2/12)*k;
      const px = this.x + this.radius * Math.cos(a);
      const py = this.y + this.radius * Math.sin(a);
      if(k===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.closePath();
    ctx.fillStyle=sectionGradient(this.baseColor,this.x,this.y,this.radius);
    ctx.fill();
    ctx.lineWidth=1.5;
    ctx.strokeStyle='rgba(255,255,255,0.7)';
    ctx.stroke();

    const time=(performance.now()-this.startTime)/1000;
    ctx.save();
    ctx.clip();
    ctx.globalAlpha=0.25;
    const angle=time*0.5;
    const grad=ctx.createLinearGradient(
      this.x + Math.cos(angle)*this.radius,
      this.y + Math.sin(angle)*this.radius,
      this.x - Math.cos(angle)*this.radius,
      this.y - Math.sin(angle)*this.radius
    );
    grad.addColorStop(0,'rgba(255,255,255,0)');
    grad.addColorStop(0.5,'rgba(255,255,255,0.7)');
    grad.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle=grad;
    ctx.fill();
    ctx.restore();

    const stripePos=(time*80)% (this.radius*2);
    ctx.save();
    ctx.clip();
    ctx.globalAlpha=0.3;
    const stripeGrad=ctx.createLinearGradient(
      this.x-stripePos,this.y-stripePos,
      this.x+stripePos,this.y+stripePos
    );
    stripeGrad.addColorStop(0,'rgba(255,255,255,0)');
    stripeGrad.addColorStop(0.5,'rgba(255,255,255,0.8)');
    stripeGrad.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle=stripeGrad;
    ctx.fill();
    ctx.restore();

    if(this.showNumber){
      ctx.save();
      ctx.font=`${this.radius*0.9}px Georgia`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillStyle=goldGradient(this.x,this.y,this.radius);
      ctx.shadowColor='rgba(0,0,0,0.6)';
      ctx.shadowBlur=6;
      ctx.fillText(this.note,this.x,this.y);
      ctx.restore();
    }
  }
}

let running=false,current=null,nextTime=0,last=null;
function loop(ts){
  if(!last) last=ts;
  const dt=(ts-last)/1000; last=ts;
  ctx.clearRect(0,0,W,H);
  drawWheel();
  const t=performance.now()/1000;
  if(running){
    if(current){
      current.update(dt,t);
      current.draw();
      if(current.done){
        current=null;
        const txt=document.getElementById('goldText');
        txt.textContent='?';
        txt.classList.add('blink');
        nextTime=t+SILENCE;
      }
    } else if(t>=nextTime){
      current=new Dodecagon(Math.floor(Math.random()*12));
    }
  }
  requestAnimationFrame(loop);
}

function drawWheel(){
  const seg=Math.PI*2/12;
  for(let i=0;i<12;i++){
    ctx.beginPath();
    ctx.moveTo(CX,CY);
    ctx.arc(CX,CY,R,seg*i-Math.PI/2,seg*(i+1)-Math.PI/2);
    ctx.closePath();
    ctx.fillStyle=COLORS[i];
    ctx.fill();
  }
  ctx.beginPath();
  ctx.arc(CX,CY,R,0,Math.PI*2);
  ctx.lineWidth=2;
  ctx.strokeStyle='rgba(255,255,255,0.1)';
  ctx.stroke();
}
requestAnimationFrame(loop);

function start(){
  if(!running){
    running=true;
    document.getElementById('overlay').style.display='none';
  } else {
    if(!document.fullscreenElement) document.documentElement.requestFullscreen();
    else document.exitFullscreen();
  }
}
document.addEventListener('keydown',start);
document.addEventListener('pointerdown',start);
</script>
</body>
</html>
