
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Pearl Dodecagon with Sacred Geometry</title>
<style>
  html,body{
    margin:0;height:100%;overflow:hidden;
    background:#000;font-family:sans-serif;
  }
  /* --- 12 perfectly tiled vertical bars --- */
  .bar{
    position:absolute;
    top:0;height:100%;
    width:calc(100% / 12);
    transition: filter 0.3s ease;
  }
  /* precise left offsets */
  .bar:nth-child(1)  {left:calc(100%/12*0); background:#FF0018;}
  .bar:nth-child(2)  {left:calc(100%/12*1); background:#FFA52C;}
  .bar:nth-child(3)  {left:calc(100%/12*2); background:#FFFF41;}
  .bar:nth-child(4)  {left:calc(100%/12*3); background:#008018;}
  .bar:nth-child(5)  {left:calc(100%/12*4); background:#0000F9;}
  .bar:nth-child(6)  {left:calc(100%/12*5); background:#86007D;}
  .bar:nth-child(7)  {left:calc(100%/12*6); background:#FFFFFF;}
  .bar:nth-child(8)  {left:calc(100%/12*7); background:#000000;}
  .bar:nth-child(9)  {left:calc(100%/12*8); background:#784F17;}
  .bar:nth-child(10) {left:calc(100%/12*9); background:#FF69B4;}
  .bar:nth-child(11) {left:calc(100%/12*10);background:#00CED1;}
  .bar:nth-child(12) {left:calc(100%/12*11);background:#808080;}
  
  /* Bar number captions */
  .bar::before{
    content:attr(data-num);
    position:absolute;
    top:-5px;
    left:50%;
    transform:translateX(-50%);
    font-family:'Georgia',serif;
    font-weight:bold;
    font-size:5vmin;
    background:linear-gradient(45deg,#f5d76e 0%,#ffcc00 20%,#d4a017 40%,#ffd700 60%,#b8860b 80%,#ffcc00 100%);
    -webkit-background-clip:text;
    background-clip:text;
    color:transparent;
    text-shadow:
      0 0 4px rgba(255,215,0,0.6),
      0 0 8px rgba(255,223,100,0.4),
      1px 1px 2px rgba(0,0,0,0.7);
    z-index:4;
  }
  
  /* Sacred geometry overlay */
  .sacred-geometry {
    position:absolute;
    top:0;
    left:0;
    width:100%;
    height:100%;
    pointer-events:none;
    opacity:0;
    transition: opacity 0.3s ease;
    z-index:3;
  }
  
  .bar.resonating .sacred-geometry {
    opacity:1;
  }
  
  .bar.resonating {
    animation: subtle-pulse 2s ease-in-out infinite;
  }
  
  /* Special enhanced effect for white bar */
  .bar:nth-child(7).resonating {
    filter: brightness(1.5) contrast(1.2);
    animation: white-bar-special 0.5s ease-in-out infinite;
  }
  
  @keyframes white-bar-special {
    0%, 100% { 
      transform: scaleX(1);
      filter: brightness(1.5) contrast(1.2) hue-rotate(0deg);
    }
    50% { 
      transform: scaleX(1.05);
      filter: brightness(1.8) contrast(1.3) hue-rotate(10deg);
    }
  }
  
  @keyframes subtle-pulse {
    0%, 100% { transform: scaleX(1); }
    50% { transform: scaleX(1.02); }
  }
  
  /* drifting vertical shimmer */
  .clouds{
    position:absolute;
    inset:0;
    z-index:5;
    pointer-events:none;
    overflow:hidden;
  }
  .clouds::before{
    content:'';
    position:absolute;
    width:100%;
    height:200%;
    top:0;
    left:0;
    background:repeating-linear-gradient(
      180deg,
      rgba(255,255,255,0.05) 0,
      rgba(255,255,255,0.05) 4px,
      transparent 4px,
      transparent 40px,
      rgba(255,255,255,0.05) 40px,
      rgba(255,255,255,0.05) 44px,
      transparent 44px,
      transparent 80px
    );
    animation:driftUp 6s linear infinite;
  }
  @keyframes driftUp{
    0%{transform:translateY(0);}
    100%{transform:translateY(-80px);}
  }
  
  #c{position:absolute;top:0;left:0;width:100%;height:100%;z-index:10;}
  
  /* gold glitter center text */
  #goldText{
    position:fixed;
    top:50%;left:50%;
    transform:translate(-50%,-50%);
    z-index:50;
    font-family:'Georgia',serif;
    font-weight:900;
    font-size:36vmin;
    letter-spacing:2px;
    text-align:center;
    background:linear-gradient(45deg,#f5d76e 0%,#ffcc00 20%,#d4a017 40%,#ffd700 60%,#b8860b 80%,#ffcc00 100%);
    -webkit-background-clip:text;
    color:transparent;
    text-shadow:
      0 0 8px rgba(255,215,0,0.6),
      0 0 12px rgba(255,223,100,0.4),
      2px 2px 4px rgba(0,0,0,0.5);
    animation:shine 3s linear infinite;
  }
  .blink{animation:blink 0.3s step-start infinite;}
  @keyframes blink {50%{opacity:0;}}
  @keyframes shine {0%{background-position:0 0;}100%{background-position:200% 0;}}
  
  #overlay{
    position:fixed;inset:0;
    display:flex;align-items:center;justify-content:center;
    z-index:60;color:#fff;background:rgba(0,0,0,0.5);
    font-size:1.2rem;
  }
</style>
</head>
<body>
<!-- 12 perfectly even vertical bars with sacred geometry -->
<div class="bar" data-num="40"><canvas class="sacred-geometry"></canvas></div>
<div class="bar" data-num="41"><canvas class="sacred-geometry"></canvas></div>
<div class="bar" data-num="42"><canvas class="sacred-geometry"></canvas></div>
<div class="bar" data-num="43"><canvas class="sacred-geometry"></canvas></div>
<div class="bar" data-num="44"><canvas class="sacred-geometry"></canvas></div>
<div class="bar" data-num="45"><canvas class="sacred-geometry"></canvas></div>
<div class="bar" data-num="46"><canvas class="sacred-geometry"></canvas></div>
<div class="bar" data-num="47"><canvas class="sacred-geometry"></canvas></div>
<div class="bar" data-num="48"><canvas class="sacred-geometry"></canvas></div>
<div class="bar" data-num="49"><canvas class="sacred-geometry"></canvas></div>
<div class="bar" data-num="50"><canvas class="sacred-geometry"></canvas></div>
<div class="bar" data-num="51"><canvas class="sacred-geometry"></canvas></div>

<div class="clouds"></div>
<canvas id="c"></canvas>
<div id="overlay">Press any key or tap to start (key toggles fullscreen)</div>
<div id="goldText" class="blink">?</div>

<script>
const SOUND_BASE="https://cubicpostcode.com/screensaver/";
const COLORS=['#FF0018','#FFA52C','#FFFF41','#008018','#0000F9','#86007D',
              '#FFFFFF','#000000','#784F17','#FF69B4','#00CED1','#808080'];
const NOTES=Array.from({length:12},(_,i)=>SOUND_BASE+`note${40+i}.mp3`);
const TRAVEL_TIME=8, SILENCE=2, FREEZE=0.5;

const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
let W,H,CX,CY,R,DPR;
let activeBarIndex = -1;
let animationFrameId = null;

// Sacred geometry patterns
const SACRED_PATTERNS = [
  'flowerOfLife',
  'metatronsCube',
  'sriYantra',
  'vesicaPiscis',
  'seedOfLife',
  'treeOfLife',
  'hexagonalGrid',
  'goldenSpiral',
  'platonicSolids',
  'merkaba',
  'torusKnot',
  'infinitySymbol'
];

// Initialize sacred geometry for all bars
function initSacredGeometry() {
  const geometryCanvases = document.querySelectorAll('.sacred-geometry');
  geometryCanvases.forEach((gCanvas, idx) => {
    const barWidth = window.innerWidth / 12;
    const barHeight = window.innerHeight;
    
    gCanvas.width = barWidth;
    gCanvas.height = barHeight;
  });
}

// Draw Flower of Life pattern
function drawFlowerOfLife(gctx, cx, cy, radius, time) {
  const baseRadius = radius / 3;
  const positions = [];
  
  // Center circle
  positions.push({x: cx, y: cy});
  
  // Six surrounding circles (first layer)
  for(let i = 0; i < 6; i++) {
    const angle = (Math.PI * 2 / 6) * i;
    positions.push({
      x: cx + Math.cos(angle) * baseRadius,
      y: cy + Math.sin(angle) * baseRadius
    });
  }
  
  // Second layer (12 circles)
  for(let i = 0; i < 12; i++) {
    const angle = (Math.PI * 2 / 12) * i;
    const dist = i % 2 === 0 ? baseRadius * 2 : baseRadius * Math.sqrt(3);
    positions.push({
      x: cx + Math.cos(angle) * dist,
      y: cy + Math.sin(angle) * dist
    });
  }
  
  // Draw all circles with animation
  positions.forEach((pos, idx) => {
    const phase = time * 2 + idx * 0.2;
    const pulseScale = 1 + Math.sin(phase) * 0.1;
    const opacity = 0.3 + Math.sin(phase) * 0.2;
    
    gctx.beginPath();
    gctx.arc(pos.x, pos.y, baseRadius * pulseScale, 0, Math.PI * 2);
    gctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
    gctx.lineWidth = 1.5;
    gctx.stroke();
    
    // Add glow
    gctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
    gctx.shadowBlur = 10;
    gctx.stroke();
    gctx.shadowBlur = 0;
  });
}

// Draw Metatron's Cube
function drawMetatronsCube(gctx, cx, cy, radius, time) {
  const points = [];
  const layers = 2;
  
  // Create points for cube vertices
  for(let layer = 0; layer < layers; layer++) {
    const z = layer === 0 ? -1 : 1;
    for(let i = 0; i < 6; i++) {
      const angle = (Math.PI * 2 / 6) * i + time * 0.5;
      const r = radius * 0.5;
      points.push({
        x: cx + Math.cos(angle) * r * (1 + z * 0.2),
        y: cy + Math.sin(angle) * r * (1 + z * 0.2)
      });
    }
  }
  
  // Center point
  points.push({x: cx, y: cy});
  
  // Draw all connections
  gctx.strokeStyle = `rgba(255, 255, 255, 0.2)`;
  gctx.lineWidth = 1;
  
  for(let i = 0; i < points.length; i++) {
    for(let j = i + 1; j < points.length; j++) {
      const distance = Math.hypot(points[j].x - points[i].x, points[j].y - points[i].y);
      const opacity = Math.max(0, 0.3 - distance / (radius * 2));
      
      gctx.beginPath();
      gctx.moveTo(points[i].x, points[i].y);
      gctx.lineTo(points[j].x, points[j].y);
      gctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
      gctx.stroke();
    }
  }
  
  // Draw points as circles
  points.forEach((p, idx) => {
    const pulse = Math.sin(time * 3 + idx * 0.5) * 0.5 + 0.5;
    gctx.beginPath();
    gctx.arc(p.x, p.y, 3 + pulse * 2, 0, Math.PI * 2);
    gctx.fillStyle = `rgba(255, 255, 255, ${0.6 + pulse * 0.4})`;
    gctx.fill();
  });
}

// Draw Sri Yantra inspired pattern
function drawSriYantra(gctx, cx, cy, radius, time) {
  const triangles = 9;
  
  for(let i = 0; i < triangles; i++) {
    const scale = 1 - i * 0.1;
    const rotation = time * 0.3 + (i % 2 === 0 ? 0 : Math.PI);
    const opacity = 0.5 - i * 0.05;
    
    gctx.save();
    gctx.translate(cx, cy);
    gctx.rotate(rotation);
    
    // Draw triangle
    gctx.beginPath();
    for(let j = 0; j < 3; j++) {
      const angle = (Math.PI * 2 / 3) * j - Math.PI / 2;
      const x = Math.cos(angle) * radius * scale;
      const y = Math.sin(angle) * radius * scale;
      if(j === 0) gctx.moveTo(x, y);
      else gctx.lineTo(x, y);
    }
    gctx.closePath();
    
    gctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
    gctx.lineWidth = 1.5;
    gctx.stroke();
    
    gctx.restore();
  }
  
  // Central bindu point
  const bindyPulse = Math.sin(time * 4) * 0.5 + 0.5;
  gctx.beginPath();
  gctx.arc(cx, cy, 5 + bindyPulse * 3, 0, Math.PI * 2);
  gctx.fillStyle = `rgba(255, 255, 255, ${0.8})`;
  gctx.fill();
}

// Draw Vesica Piscis
function drawVesicaPiscis(gctx, cx, cy, radius, time) {
  const offset = radius * 0.5;
  const rotation = time * 0.2;
  
  gctx.save();
  gctx.translate(cx, cy);
  gctx.rotate(rotation);
  
  // Draw two overlapping circles
  gctx.beginPath();
  gctx.arc(-offset/2, 0, radius * 0.6, 0, Math.PI * 2);
  gctx.strokeStyle = `rgba(255, 255, 255, 0.4)`;
  gctx.lineWidth = 2;
  gctx.stroke();
  
  gctx.beginPath();
  gctx.arc(offset/2, 0, radius * 0.6, 0, Math.PI * 2);
  gctx.stroke();
  
  // Highlight the vesica (intersection)
  gctx.globalCompositeOperation = 'lighten';
  gctx.beginPath();
  gctx.arc(-offset/2, 0, radius * 0.6, -Math.PI/3, Math.PI/3);
  gctx.arc(offset/2, 0, radius * 0.6, 2*Math.PI/3, 4*Math.PI/3);
  gctx.fillStyle = `rgba(255, 255, 255, ${0.1 + Math.sin(time * 3) * 0.1})`;
  gctx.fill();
  gctx.globalCompositeOperation = 'source-over';
  
  gctx.restore();
}

// Draw special crystalline prism effect for white bar
function drawCrystallinePrism(gctx, width, height, time) {
  gctx.clearRect(0, 0, width, height);
  
  // FIRST: Draw a dark/colored background to make effects visible
  const bgGradient = gctx.createLinearGradient(0, 0, width, height);
  const bgHue = (time * 20) % 360;
  bgGradient.addColorStop(0, `hsla(${bgHue}, 70%, 20%, 0.8)`);
  bgGradient.addColorStop(0.5, `hsla(${(bgHue + 60) % 360}, 80%, 15%, 0.9)`);
  bgGradient.addColorStop(1, `hsla(${(bgHue + 120) % 360}, 70%, 20%, 0.8)`);
  gctx.fillStyle = bgGradient;
  gctx.fillRect(0, 0, width, height);
  
  // Create prismatic light refraction effect
  const numPrisms = 5;
  const centerX = width / 2;
  
  for(let p = 0; p < numPrisms; p++) {
    const yPos = (p + 0.5) * (height / numPrisms);
    const phase = time * 2 + p * 0.7;
    
    // Draw main crystal structure
    gctx.save();
    gctx.translate(centerX, yPos);
    gctx.rotate(Math.sin(phase) * 0.3);
    
    // Central hexagonal crystal with rainbow fill
    const hexRadius = 40 + Math.sin(phase) * 15;
    for(let layer = 0; layer < 6; layer++) {
      const layerScale = 1 - layer * 0.12;
      const layerRotation = layer * Math.PI / 12 + time * (0.3 + layer * 0.05);
      
      gctx.save();
      gctx.rotate(layerRotation);
      
      gctx.beginPath();
      for(let i = 0; i < 6; i++) {
        const angle = (Math.PI * 2 / 6) * i;
        const x = Math.cos(angle) * hexRadius * layerScale;
        const y = Math.sin(angle) * hexRadius * layerScale;
        if(i === 0) gctx.moveTo(x, y);
        else gctx.lineTo(x, y);
      }
      gctx.closePath();
      
      // Intense rainbow prismatic colors
      const hue = (time * 80 + layer * 60 + p * 40) % 360;
      
      // Fill with semi-transparent rainbow
      gctx.fillStyle = `hsla(${hue}, 100%, 50%, ${0.3 - layer * 0.05})`;
      gctx.fill();
      
      // Bold colored stroke
      gctx.strokeStyle = `hsla(${hue}, 100%, 60%, ${0.9 - layer * 0.1})`;
      gctx.lineWidth = 3;
      gctx.shadowColor = `hsla(${hue}, 100%, 50%, 0.8)`;
      gctx.shadowBlur = 15;
      gctx.stroke();
      gctx.shadowBlur = 0;
      
      gctx.restore();
    }
    
    // Intense rainbow light rays
    for(let ray = 0; ray < 12; ray++) {
      const rayAngle = (Math.PI * 2 / 12) * ray + time * 0.3;
      const rayLength = 70 + Math.sin(time * 3 + ray) * 25;
      const rayHue = (ray * 30 + time * 100) % 360;
      
      const gradient = gctx.createLinearGradient(
        0, 0,
        Math.cos(rayAngle) * rayLength,
        Math.sin(rayAngle) * rayLength
      );
      gradient.addColorStop(0, `hsla(${rayHue}, 100%, 50%, 0.8)`);
      gradient.addColorStop(0.3, `hsla(${(rayHue + 30) % 360}, 100%, 60%, 0.5)`);
      gradient.addColorStop(0.6, `hsla(${(rayHue + 60) % 360}, 100%, 70%, 0.3)`);
      gradient.addColorStop(1, `hsla(${(rayHue + 90) % 360}, 100%, 80%, 0)`);
      
      gctx.beginPath();
      gctx.moveTo(0, 0);
      gctx.lineTo(
        Math.cos(rayAngle) * rayLength,
        Math.sin(rayAngle) * rayLength
      );
      
      gctx.strokeStyle = gradient;
      gctx.lineWidth = 5;
      gctx.shadowColor = `hsla(${rayHue}, 100%, 50%, 0.9)`;
      gctx.shadowBlur = 10;
      gctx.stroke();
      gctx.shadowBlur = 0;
    }
    
    // Bright diamond sparkles
    for(let s = 0; s < 8; s++) {
      const sparkAngle = (Math.PI * 2 / 8) * s + time;
      const sparkDist = 55 + Math.sin(time * 4 + s * 0.8) * 20;
      const sparkX = Math.cos(sparkAngle) * sparkDist;
      const sparkY = Math.sin(sparkAngle) * sparkDist;
      const sparkSize = 5 + Math.sin(time * 5 + s) * 3;
      
      // Draw diamond shape with intense colors
      gctx.save();
      gctx.translate(sparkX, sparkY);
      gctx.rotate(time * 2 + s);
      
      gctx.beginPath();
      gctx.moveTo(0, -sparkSize);
      gctx.lineTo(sparkSize, 0);
      gctx.lineTo(0, sparkSize);
      gctx.lineTo(-sparkSize, 0);
      gctx.closePath();
      
      const sparkHue = (time * 120 + s * 45) % 360;
      
      // Bright fill
      gctx.fillStyle = `hsla(${sparkHue}, 100%, 60%, ${0.8 + Math.sin(time * 6 + s) * 0.2})`;
      gctx.fill();
      
      // Glowing stroke
      gctx.strokeStyle = `hsla(${sparkHue}, 100%, 80%, 1)`;
      gctx.lineWidth = 2;
      gctx.shadowColor = `hsla(${sparkHue}, 100%, 60%, 1)`;
      gctx.shadowBlur = 8;
      gctx.stroke();
      gctx.shadowBlur = 0;
      
      gctx.restore();
    }
    
    gctx.restore();
  }
  
  // Add intense rainbow aurora waves
  for(let wave = 0; wave < 4; wave++) {
    gctx.beginPath();
    for(let x = 0; x <= width; x += 2) {
      const y = height / 2 + 
                Math.sin(x * 0.02 + time * 2 + wave) * 80 +
                Math.cos(x * 0.01 + time * 1.5 + wave * 0.5) * 40;
      if(x === 0) gctx.moveTo(x, y);
      else gctx.lineTo(x, y);
    }
    
    const waveHue = (time * 60 + wave * 90) % 360;
    gctx.strokeStyle = `hsla(${waveHue}, 100%, 50%, ${0.6 - wave * 0.1})`;
    gctx.lineWidth = 4 - wave;
    gctx.shadowColor = `hsla(${waveHue}, 100%, 50%, 0.8)`;
    gctx.shadowBlur = 10;
    gctx.stroke();
    gctx.shadowBlur = 0;
  }
  
  // Colored particle field
  for(let i = 0; i < 60; i++) {
    const particleX = (i * 19 + time * 40) % width;
    const particleY = (i * 23 + time * 30) % height;
    const particleSize = Math.sin(time * 3 + i) * 2 + 3;
    const particleAlpha = Math.sin(time * 4 + i * 0.5) * 0.4 + 0.6;
    const particleHue = (i * 20 + time * 50) % 360;
    
    gctx.globalAlpha = particleAlpha;
    gctx.fillStyle = `hsla(${particleHue}, 100%, 70%, 1)`;
    gctx.shadowColor = `hsla(${particleHue}, 100%, 50%, 1)`;
    gctx.shadowBlur = particleSize * 2;
    gctx.beginPath();
    gctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
    gctx.fill();
    gctx.shadowBlur = 0;
  }
  gctx.globalAlpha = 1;
}

// Main kaleidoscopic pattern renderer
function drawKaleidoscopicPattern(gctx, width, height, barIndex, time) {
  // Special effect for white bar (index 6, note 46)
  // The 7th bar (index 6) is the white one
  if(barIndex === 6) {
    console.log('Drawing crystalline prism for white bar');
    drawCrystallinePrism(gctx, width, height, time);
    return;
  }
  
  gctx.clearRect(0, 0, width, height);
  
  // Create multiple instances of the pattern vertically
  const numPatterns = Math.ceil(height / 150);
  
  for(let i = 0; i < numPatterns; i++) {
    const cy = i * 150 + 75;
    const cx = width / 2;
    const radius = 50;
    
    // Choose pattern based on bar index
    const patternType = barIndex % 4;
    
    switch(patternType) {
      case 0:
        drawFlowerOfLife(gctx, cx, cy, radius, time);
        break;
      case 1:
        drawMetatronsCube(gctx, cx, cy, radius, time);
        break;
      case 2:
        drawSriYantra(gctx, cx, cy, radius, time);
        break;
      case 3:
        drawVesicaPiscis(gctx, cx, cy, radius, time);
        break;
    }
    
    // Add rotating mandala overlay
    gctx.save();
    gctx.translate(cx, cy);
    gctx.rotate(time * 0.5);
    
    for(let j = 0; j < 12; j++) {
      const angle = (Math.PI * 2 / 12) * j;
      const lineRadius = radius * 1.2;
      
      gctx.beginPath();
      gctx.moveTo(0, 0);
      gctx.lineTo(Math.cos(angle) * lineRadius, Math.sin(angle) * lineRadius);
      gctx.strokeStyle = `rgba(255, 255, 255, 0.1)`;
      gctx.lineWidth = 1;
      gctx.stroke();
      
      // Add dots at endpoints
      const dotPulse = Math.sin(time * 3 + j * 0.5) * 0.5 + 0.5;
      gctx.beginPath();
      gctx.arc(
        Math.cos(angle) * lineRadius,
        Math.sin(angle) * lineRadius,
        2 + dotPulse,
        0,
        Math.PI * 2
      );
      gctx.fillStyle = `rgba(255, 255, 255, ${0.3 + dotPulse * 0.3})`;
      gctx.fill();
    }
    
    gctx.restore();
  }
  
  // Add overall shimmer effect
  const shimmerGradient = gctx.createLinearGradient(0, 0, width, height);
  shimmerGradient.addColorStop(0, `rgba(255, 255, 255, 0)`);
  shimmerGradient.addColorStop(0.5 + Math.sin(time * 2) * 0.3, `rgba(255, 255, 255, 0.05)`);
  shimmerGradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
  gctx.fillStyle = shimmerGradient;
  gctx.fillRect(0, 0, width, height);
}

// Activate sacred geometry animation
function activateBarResonance(barIndex) {
  const bars = document.querySelectorAll('.bar');
  bars.forEach(bar => bar.classList.remove('resonating'));
  
  if(barIndex >= 0 && barIndex < 12) {
    bars[barIndex].classList.add('resonating');
    activeBarIndex = barIndex;
    
    // Cancel previous animation if exists
    if(animationFrameId) cancelAnimationFrame(animationFrameId);
    
    // Start animation loop
    animateSacredGeometry(barIndex);
  }
}

// Deactivate resonance
function deactivateBarResonance() {
  const bars = document.querySelectorAll('.bar');
  bars.forEach(bar => bar.classList.remove('resonating'));
  activeBarIndex = -1;
  if(animationFrameId) {
    cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
  }
}

// Animation loop for sacred geometry
function animateSacredGeometry(barIndex) {
  if(activeBarIndex !== barIndex) return;
  
  const gCanvas = document.querySelectorAll('.sacred-geometry')[barIndex];
  if(!gCanvas) return;
  
  const gctx = gCanvas.getContext('2d');
  const width = gCanvas.width;
  const height = gCanvas.height;
  const time = performance.now() / 1000;
  
  // Debug: log when white bar is active
  if(barIndex === 6) {
    console.log('White bar (46) is active!');
  }
  
  drawKaleidoscopicPattern(gctx, width, height, barIndex, time);
  
  animationFrameId = requestAnimationFrame(() => animateSacredGeometry(barIndex));
}

function resize(){
  DPR=window.devicePixelRatio||1;
  W=innerWidth;H=innerHeight;
  CX=W/2;CY=H/2;R=Math.min(W,H)*0.45;
  canvas.width=W*DPR;canvas.height=H*DPR;
  canvas.style.width=W+'px';canvas.style.height=H+'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
  initSacredGeometry();
}
resize();
addEventListener('resize',resize);

function sectionGradient(base,x,y,r){
  const rgb = base.match(/\w\w/g).map(c=>parseInt(c,16));
  const g = ctx.createRadialGradient(x-r*0.3,y-r*0.3,r*0.1,x,y,r);
  g.addColorStop(0,`rgba(${rgb[0]},${rgb[1]},${rgb[2]},1)`);
  g.addColorStop(0.5,`rgba(${rgb[0]},${rgb[1]},${rgb[2]},0.7)`);
  g.addColorStop(1,`rgba(${rgb[0]},${rgb[1]},${rgb[2]},0.4)`);
  return g;
}
function goldGradient(x,y,r){
  const g=ctx.createLinearGradient(x-r,y-r,x+r,y+r);
  g.addColorStop(0,'#f5d76e');
  g.addColorStop(0.2,'#ffcc00');
  g.addColorStop(0.4,'#d4a017');
  g.addColorStop(0.6,'#ffd700');
  g.addColorStop(0.8,'#b8860b');
  g.addColorStop(1,'#ffcc00');
  return g;
}

class Dodecagon{
  constructor(i){
    const seg=Math.PI*2/12;
    this.idx=i;
    this.ang=seg*i-Math.PI/2+seg/2;
    this.x=CX;this.y=CY;
    this.radius=0;
    this.speed=R/TRAVEL_TIME;
    this.target=[CX+Math.cos(this.ang)*R, CY+Math.sin(this.ang)*R];
    this.travelled=0;
    this.note=40+i;
    this.audio=new Audio(NOTES[i]);
    this.audio.crossOrigin='anonymous';
    this.played=false;this.freezeEnd=null;
    this.showNumber=false;
    this.startTime=performance.now();
    this.baseColor=COLORS[i];
  }
  update(dt,t){
    if(this.freezeEnd && t>this.freezeEnd){
      deactivateBarResonance();
      this.done=true;
      return;
    }
    if(!this.played){
      this.audio.play().catch(()=>{});
      this.played=true;
      activateBarResonance(this.idx);
    }
    const move=this.speed*dt;
    this.x+=Math.cos(this.ang)*move;
    this.y+=Math.sin(this.ang)*move;
    this.travelled+=move;
    this.radius = R * 0.12 * (this.travelled/R);
    if(this.travelled>=R/2 && !this.showNumber){
      this.showNumber=true;
      const txt=document.getElementById('goldText');
      txt.textContent=this.note;
      txt.classList.remove('blink');
    }
    const remain=Math.hypot(this.target[0]-this.x,this.target[1]-this.y);
    if(remain<2 && !this.freezeEnd){this.freezeEnd=t+FREEZE;}
  }
  draw(){
    ctx.beginPath();
    for(let k=0;k<12;k++){
      const a = (Math.PI*2/12)*k;
      const px = this.x + this.radius * Math.cos(a);
      const py = this.y + this.radius * Math.sin(a);
      if(k===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.closePath();
    ctx.fillStyle=sectionGradient(this.baseColor,this.x,this.y,this.radius);
    ctx.fill();
    ctx.lineWidth=1.5;
    ctx.strokeStyle='rgba(255,255,255,0.7)';
    ctx.stroke();

    const time=(performance.now()-this.startTime)/1000;
    ctx.save();
    ctx.clip();
    ctx.globalAlpha=0.25;
    const angle=time*0.5;
    const grad=ctx.createLinearGradient(
      this.x + Math.cos(angle)*this.radius,
      this.y + Math.sin(angle)*this.radius,
      this.x - Math.cos(angle)*this.radius,
      this.y - Math.sin(angle)*this.radius
    );
    grad.addColorStop(0,'rgba(255,255,255,0)');
    grad.addColorStop(0.5,'rgba(255,255,255,0.7)');
    grad.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle=grad;
    ctx.fill();
    ctx.restore();

    const stripePos=(time*80)% (this.radius*2);
    ctx.save();
    ctx.clip();
    ctx.globalAlpha=0.3;
    const stripeGrad=ctx.createLinearGradient(
      this.x-stripePos,this.y-stripePos,
      this.x+stripePos,this.y+stripePos
    );
    stripeGrad.addColorStop(0,'rgba(255,255,255,0)');
    stripeGrad.addColorStop(0.5,'rgba(255,255,255,0.8)');
    stripeGrad.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle=stripeGrad;
    ctx.fill();
    ctx.restore();

    if(this.showNumber){
      ctx.save();
      ctx.font=`${this.radius*0.9}px Georgia`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillStyle=goldGradient(this.x,this.y,this.radius);
      ctx.shadowColor='rgba(0,0,0,0.6)';
      ctx.shadowBlur=6;
      ctx.fillText(this.note,this.x,this.y);
      ctx.restore();
    }
  }
}

let running=false,current=null,nextTime=0,last=null;
function loop(ts){
  if(!last) last=ts;
  const dt=(ts-last)/1000; last=ts;
  ctx.clearRect(0,0,W,H);
  drawWheel();
  const t=performance.now()/1000;
  if(running){
    if(current){
      current.update(dt,t);
      current.draw();
      if(current.done){
        current=null;
        const txt=document.getElementById('goldText');
        txt.textContent='?';
        txt.classList.add('blink');
        nextTime=t+SILENCE;
      }
    } else if(t>=nextTime){
      current=new Dodecagon(Math.floor(Math.random()*12));
    }
  }
  requestAnimationFrame(loop);
}

function drawWheel(){
  const seg=Math.PI*2/12;
  for(let i=0;i<12;i++){
    ctx.beginPath();
    ctx.moveTo(CX,CY);
    ctx.arc(CX,CY,R,seg*i-Math.PI/2,seg*(i+1)-Math.PI/2);
    ctx.closePath();
    ctx.fillStyle=COLORS[i];
    ctx.fill();
  }
  ctx.beginPath();
  ctx.arc(CX,CY,R,0,Math.PI*2);
  ctx.lineWidth=2;
  ctx.strokeStyle='rgba(255,255,255,0.1)';
  ctx.stroke();
}
requestAnimationFrame(loop);

function start(){
  if(!running){
    running=true;
    document.getElementById('overlay').style.display='none';
  } else {
    if(!document.fullscreenElement) document.documentElement.requestFullscreen();
    else document.exitFullscreen();
  }
}
document.addEventListener('keydown',start);
document.addEventListener('pointerdown',start);
</script>
</body>
</html>
