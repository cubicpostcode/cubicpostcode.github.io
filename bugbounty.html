We have a budget of Â£100 to fix the code bug.

We firmly believe that we are getting closer to fixing it.
Here is some code generated by ChatGPT that may help fing the bug.

Contacts and social networks: at the end of CubicPostcode website final page. 
feedback@cubicpostcode.com

''' We are given two coordinates x and y, corresponding to cartesian coordinates
in a plane (x, horizontal axis and y the vertical axis). We have tiles of one unit by one unit each.
The first tile, tile=1, is of all points of x between 0 and -1 and with y between 0 and 1. The second tile, with x between 0 and 1 
and y between 0 and 1, the third tile x between 0 and 1 and y between 0 and -1. The fourth tile with
x between 0 and -1 and y between 0 and -1. The fifth tile with x between -1 and -2 and y between 1 and 2.
And so on, in spiral around and around, adding more tiles around and around in piral. We are told how peripheric is the tile situated with
an integer called "peripheric_square_n" and are also told the four corner tiles in the corners of those
perimetric peripheric square with tiles (left_top_tile, right_top_tile, right_bottom_tile, left_bottom_tile).
Using the four corner tiles mentioned, and also peripheric_square_n and the two coordinates we want to find the number of the specific tile.
For example for: 
1) x = -0.4 and y = 0.4 (Given: peripheric_square_n = 1 , left_top_tile = 1, right_top_tile = 2, right_bottom_tile = 3, left_bottom_tile = 4) we should get tile_n= 1.
2) x = -0.4 and y = 1.4 (Given: peripheric_square_n = 2 , left_top_tile = 5, right_top_tile = 8, right_bottom_tile = 11, left_bottom_tile = 14) we should get tile_n= 6.
3) x = -0.4 and y = 2.4 (Given: peripheric_square_n = 3 , left_top_tile = 17, right_top_tile = 22, right_bottom_tile = 27, left_bottom_tile = 32) we should get tile_n= 19.
4) x = -1.4 and y = 0.4 (Given: peripheric_square_n = 1 , left_top_tile = 5 , right_top_tile = 8, right_bottom_tile = 11, left_bottom_tile = 14) we should get tile_n= 16.
5) x =  1.4 and y = 1.4 (Given: peripheric_square_n = 2 , left_top_tile = 5, right_top_tile = 8, right_bottom_tile = 11, left_bottom_tile = 14) we should get tile_n= 8.
6) x =  2.4 and y = 2.4 (Given: peripheric_square_n = 3 , left_top_tile = 17, right_top_tile = 22, right_bottom_tile = 27, left_bottom_tile = 32) we should get tile_n= 22.
7) x = -2.4 and y = 0.4 (Given: peripheric_square_n = 3 , left_top_tile = 17, right_top_tile = 22, right_bottom_tile = 27, left_bottom_tile = 32) we should get tile_n= 35.
8) x =  2.4 and y = 1.4 (Given: peripheric_square_n = 3 , left_top_tile = 17, right_top_tile = 22, right_bottom_tile = 27, left_bottom_tile = 32) we should get tile_n= 23.
9) x =  1.4 and y = 2.4 (Given: peripheric_square_n = 3 , left_top_tile = 17, right_top_tile = 22, right_bottom_tile = 27, left_bottom_tile = 32) we should get tile_n= 18.
10) x = -2.4 and y = 1.4 (Given: peripheric_square_n = 3 , left_top_tile = 17, right_top_tile = 22 , right_bottom_tile = 27, left_bottom_tile = 32) we should get tile_n= 36.

# Show code in Python to get the tile_n number given x and y, as well as the five other values.
'''
import math

def get_tile_number(x, y, peripheric_square_n, left_top_tile, right_top_tile, right_bottom_tile, left_bottom_tile):
  

    if x<-4 and y>4:
        x = x + 4
        y = y - 4
        

   #If the value of x is negative and would be greater than the value of y if it were positive round it off to the nest digit
    if x < 0 and abs(x) > y:
       x_rounded = math.ceil(x) - 1

    elif x<0:
        x_rounded = math.ceil(x)
   #Simply round off the values of co-ordinates to get the precise locatio
    else:
        x_rounded = round(x)
    
    y_rounded = round(y)

    #Base case
    if x_rounded == y_rounded == 0:
        return 1

    max_coord = max(abs(x_rounded), abs(y_rounded))
    side_length = max_coord * 2
    tile_per_side = side_length + 1
    tile_count = tile_per_side ** 2

    if x_rounded == max_coord and y_rounded != -max_coord:
        return right_top_tile + max_coord - y_rounded
    elif y_rounded == -max_coord and x_rounded != -max_coord:
        return right_bottom_tile + max_coord + x_rounded
    elif x_rounded == -max_coord and y_rounded != max_coord:
        return left_bottom_tile + max_coord + y_rounded
    elif y_rounded == max_coord and x_rounded != max_coord:
        return left_top_tile + max_coord - x_rounded
    

    spiral_size = math.ceil(math.sqrt(tile_count))
    periphery_size = (spiral_size - 1) * 4

    if peripheric_square_n == 1:
        tile_n = left_bottom_tile + periphery_size

        if x_rounded == -max_coord:
            tile_n += math.ceil(tile_per_side * (1 - y % 1))
        elif y_rounded == -max_coord:
            tile_n += math.ceil(tile_per_side * (2 - x % 1))
        elif x_rounded == max_coord:
            tile_n += math.ceil(tile_per_side * (1 + y % 1))
        elif y_rounded == max_coord:
            tile_n += math.ceil(tile_per_side * (2 + x % 1))

    else:
        inner_spiral_size = spiral_size - 2 * (peripheric_square_n - 1)
        inner_spiral_tiles = inner_spiral_size ** 2
        inner_spiral_start = left_bottom_tile + periphery_size + 1
        inner_spiral_end = inner_spiral_start + inner_spiral_tiles

        if x_rounded == -max_coord:
            tile_n = inner_spiral_start + (y_rounded - max_coord)
        elif y_rounded == -max_coord:
            tile_n = inner_spiral_start + inner_spiral_size + (max_coord + x_rounded)
        elif x_rounded == max_coord:
            tile_n = inner_spiral_start + (inner_spiral_size * 2) + (max_coord - y_rounded)
        elif y_rounded == max_coord:
            tile_n = inner_spiral_start + (inner_spiral_size * 3) + (y_rounded - max_coord)

        elif x_rounded < max_coord and y_rounded > -max_coord:
            tile_n = inner_spiral_start + inner_spiral_tiles

            if x_rounded == y_rounded:
                tile_n += math.ceil(inner_spiral_size * (1 - (x_rounded - inner_spiral_size) % 1))
            elif x_rounded == -y_rounded:
                tile_n += math.ceil(inner_spiral_size * (1 + (x_rounded - inner_spiral_size) % 1))
            elif x_rounded > -y_rounded and x_rounded < y_rounded:
                tile_n += math.ceil(inner_spiral_size * (2 + (y_rounded - inner_spiral_size) % 1))
            elif x_rounded < -y_rounded and x_rounded > y_rounded:
                tile_n += math.ceil(inner_spiral_size * (4 - (y_rounded - inner_spiral_size) % 1))

        else:
            periphery_start = inner_spiral_start + inner_spiral_tiles
            periphery_index = (x_rounded + y_rounded) * 2 + max_coord * 8 - 3

            if periphery_index < periphery_size:
                tile_n = periphery_start + periphery_index
            else:
                tile_n = periphery_start + (periphery_index - periphery_size)

    return int(tile_n)


# Test cases to be tested
test_cases = [
    {"x": -0.4, "y": 0.4, "peripheric_square_n": 1, "left_top_tile": 1, "right_top_tile": 2, "right_bottom_tile": 3, "left_bottom_tile": 4},
    {"x": -0.4, "y": 1.4, "peripheric_square_n": 2, "left_top_tile": 5, "right_top_tile": 8, "right_bottom_tile": 11, "left_bottom_tile": 14},
    {"x": -0.4, "y": 2.4, "peripheric_square_n": 3, "left_top_tile": 17, "right_top_tile": 22, "right_bottom_tile": 27, "left_bottom_tile": 32},
    {"x": -1.4, "y": 0.4, "peripheric_square_n": 1, "left_top_tile": 5, "right_top_tile": 8, "right_bottom_tile": 11, "left_bottom_tile": 14},
    {"x": 1.4, "y": 1.4, "peripheric_square_n": 2, "left_top_tile": 5, "right_top_tile": 8, "right_bottom_tile": 11, "left_bottom_tile": 14},
    {"x": 2.4, "y": 2.4, "peripheric_square_n": 3, "left_top_tile": 17, "right_top_tile": 22, "right_bottom_tile": 27, "left_bottom_tile": 32},
    {"x": -2.4, "y": 0.4, "peripheric_square_n": 3, "left_top_tile": 17, "right_top_tile": 22, "right_bottom_tile": 27, "left_bottom_tile": 32},
    {"x": 2.4, "y": 1.4, "peripheric_square_n": 3, "left_top_tile": 17, "right_top_tile": 22, "right_bottom_tile": 27, "left_bottom_tile": 32},
    {"x": 1.4, "y": 2.4, "peripheric_square_n": 3, "left_top_tile": 17, "right_top_tile": 22, "right_bottom_tile": 27, "left_bottom_tile": 32},
    {"x": -2.4, "y": 1.4, "peripheric_square_n": 3, "left_top_tile": 17, "right_top_tile": 22, "right_bottom_tile": 27, "left_bottom_tile": 32},
    {"x": -0.7, "y": 4.4, "peripheric_square_n": 5, "left_top_tile": 65, "right_top_tile": 74, "right_bottom_tile": 83, "left_bottom_tile": 92},
    {"x": -4.7, "y": 5.4, "peripheric_square_n": 6, "left_top_tile": 101, "right_top_tile": 112, "right_bottom_tile": 123, "left_bottom_tile": 134},
]

#Testing All Cases
for test in test_cases:
    x = test["x"]
    y = test["y"]
    peripheric_square_n = test["peripheric_square_n"]
    left_top_tile = test["left_top_tile"]
    right_top_tile = test["right_top_tile"]
    right_bottom_tile = test["right_bottom_tile"]
    left_bottom_tile = test["left_bottom_tile"]

#Printing the results
    tile_number = get_tile_number(x, y, peripheric_square_n, left_top_tile, right_top_tile, right_bottom_tile, left_bottom_tile)
    print(f"For x={x} and y={y}, the tile number is {tile_number}")
